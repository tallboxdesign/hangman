<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-translate-key="pageTitle">3D Hangman Game</title>
    <!-- Libraries loaded via CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <style>
        /* ... (CSS remains exactly the same as the previous version with the mobile menu) ... */
        /* Basic reset */
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: Arial, sans-serif; }
        canvas { display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }

        /* Game UI Container */
        #game-container { position: absolute; top: 15px; left: 15px; background: rgba(255,255,255,0.9); padding: 15px; border-radius: 8px; z-index: 100; color: #333; box-shadow: 0 6px 12px rgba(0,0,0,0.25); max-width: 400px; width: 90%; user-select: none; font-size: 14px; box-sizing: border-box; }
        #game-container * { box-sizing: border-box; }
        #game-container > *:not(#game-container-header):not(#translation-controls):not(#mobile-menu-btn) { user-select: auto; } /* Allow select except header/menu */
        #game-container-header { cursor: move; background-color: #e8e8e8; padding: 8px 15px; margin: -15px -15px 15px -15px; border-top-left-radius: 8px; border-top-right-radius: 8px; font-size: 16px; font-weight: bold; text-align: center; }

        /* Game Elements */
        #word-display { font-size: 24px; letter-spacing: 5px; margin-bottom: 15px; font-family: 'Courier New', monospace; text-align: center; min-height: 35px; word-break: break-all; line-height: 1.3; }
        #status-container { display: flex; justify-content: center; align-items: center; margin: 15px 0 10px 0; min-height: 24px; flex-wrap: wrap; }
        #status { font-weight: bold; text-align: center; color: #444; font-size: 15px; flex-grow: 1; padding-right: 5px; }
        #word-source { font-size: 12px; font-style: italic; color: #666; text-align: center; flex-shrink: 0; width: 100%; margin-top: 2px; }
        #used-letters-container { margin: 10px 0; font-family: 'Courier New', monospace; text-align: center; font-size: 14px; min-height: 20px; }
        #used-letters { font-weight: bold; color: #555; }
        #letters-container { margin: 15px 0; display: flex; flex-wrap: wrap; justify-content: center; gap: 5px; }
        .letter-button { padding: 8px 10px; margin: 0; cursor: pointer; border-radius: 4px; border: 1px solid #ccc; background: #fff; font-weight: bold; transition: all 0.15s ease-in-out; min-width: 35px; text-align: center; font-size: 14px; }
        .letter-button:hover:not(.disabled) { background: #e8f4ff; transform: translateY(-2px); box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .letter-button.disabled { background: #e0e0e0; cursor: not-allowed; opacity: 0.6; transform: none; box-shadow: none; }
        .letter-button.correct { background: #b7e8b7; border-color: #8fbc8f; color: #1a5a1a; }
        .letter-button.incorrect { background: #f8c6c6; border-color: #d8a0a0; color: #8b0000; }

        /* Word Details Placeholder */
        #word-details { display: none; }

        /* Game Controls */
        #game-controls { display: flex; justify-content: space-between; align-items: center; margin-top: 15px; gap: 10px; flex-wrap: wrap; }
        #new-game-btn { padding: 10px 15px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; transition: background 0.3s; flex-shrink: 0; font-size: 14px; }
        #new-game-btn:hover { background: #3e8e41; }
        #difficulty-select { padding: 9px; border-radius: 4px; border: 1px solid #ccc; flex-grow: 1; min-width: 150px; font-size: 14px; }

        /* Translation Controls */
        #translation-controls { margin-top: 15px; padding-top: 15px; border-top: 1px solid #ccc; display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
        #translation-controls label { font-size: 14px; font-weight: bold; margin-right: 5px; }
        #language-select { padding: 7px; border-radius: 4px; border: 1px solid #ccc; font-size: 13px; flex-grow: 1; min-width: 120px; }
        #translate-toggle-btn { padding: 7px 12px; font-size: 13px; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 4px; transition: background-color 0.3s; }
        #translate-toggle-btn:hover { background-color: #0056b3; }
        #translation-status { font-size: 12px; width: 100%; min-height: 16px; font-style: italic; color: #666; margin-top: 5px; }

        /* API Settings */
        #api-settings { margin-top: 20px; padding-top: 15px; border-top: 1px solid #ccc; }
        #api-settings h4 { text-align: center; margin-bottom: 8px; font-size: 1.1em; }
        .api-input-container { display: flex; flex-wrap: wrap; gap: 8px; margin: 10px 0; align-items: center; }
        #api-key-input { flex-grow: 1; padding: 8px; border: 1px solid #ccc; border-radius: 4px; min-width: 150px; font-size: 13px;}
        #api-model-select { padding: 8px; border-radius: 4px; border: 1px solid #ccc; font-size: 13px;}
        #api-status { font-size: 13px; margin-top: 5px; min-height: 20px; font-style: italic; }
        #api-controls { display: flex; gap: 10px; align-items: center; width: 100%; flex-wrap: wrap; }
        #api-controls label { display: flex; align-items: center; font-size: 14px; }
        #use-api-checkbox { margin-right: 5px; transform: scale(1.1); }
        #test-api-btn { padding: 7px 12px; font-size: 13px; cursor: pointer; margin-left: auto; }
        #api-key-warning { font-size: 12px; color: #888; margin-top: 5px; }

        /* Details Popup Styles */
        #details-popup-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.6); z-index: 1000; display: none; justify-content: center; align-items: center; }
        #details-popup { background: #fff; padding: 25px; border-radius: 8px; box-shadow: 0 8px 20px rgba(0,0,0,0.3); max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto; z-index: 1001; }
        #details-popup h4 { margin-top: 0; margin-bottom: 15px; font-size: 1.3em; color: #333; text-align: center; border-bottom: 1px solid #eee; padding-bottom: 10px; }
         #details-popup h5 { margin: 15px 0 5px 0; font-size: 1.1em; color: #555; font-style: italic; }
        #details-popup p { margin: 5px 0 10px 0; line-height: 1.5; font-size: 0.95em; }
        #details-popup strong { font-weight: bold; color: #111; }
         #details-popup .word-translation-block { text-align: center; margin-bottom: 15px; }
         #details-popup .word-translation { font-weight: bold; font-size: 1.2em; color: #0056b3; display: inline-block; margin-right: 15px; }
          #details-popup .word-transcription { font-style: italic; font-size: 1.1em; color: #444; display: inline-block; }
         #details-popup .section-separator { border-top: 1px dashed #ccc; margin: 15px 0; }
        #details-popup .error { color: #a00; font-style: italic; }
        #details-popup-controls { text-align: center; margin-top: 20px; }
        #details-popup-ok-btn { padding: 10px 25px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 1em; transition: background 0.3s; }
        #details-popup-ok-btn:hover { background: #0056b3; }

        /* Mobile Menu Button Default Style (Hidden) */
        #mobile-menu-btn { display: none; position: absolute; top: 8px; right: 10px; z-index: 101; padding: 5px 10px; font-size: 24px; background: #f0f0f0; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; line-height: 1; color: #333; }
        #mobile-menu-btn:hover { background: #e0e0e0; }

        /* Responsive Adjustments */
        @media (max-width: 600px) {
            #game-container { left: 5px; top: 5px; max-width: calc(100% - 10px); width: calc(100% - 10px); padding: 10px; padding-top: 45px; font-size: 13px; }
            #game-container-header { cursor: default; margin: -45px -10px 10px -10px; padding-top: 10px; padding-bottom: 10px; font-size: 15px; }

            /* Mobile Menu & Panel Styles */
            #mobile-menu-btn { display: block; }
            #mobile-collapsible-panel { display: none; margin-top: 15px; padding-top: 15px; border-top: 1px solid #ddd; max-height: 50vh; /* Limit height */ overflow-y: auto; /* Add scroll */ padding-bottom: 15px; -webkit-overflow-scrolling: touch; }
            #mobile-collapsible-panel.panel-visible { display: block; }
            #mobile-collapsible-panel #game-controls,
            #mobile-collapsible-panel #translation-controls,
            #mobile-collapsible-panel #api-settings,
            #mobile-collapsible-panel .api-input-container,
            #mobile-collapsible-panel #api-controls { flex-direction: column; align-items: stretch; width: 100%; }
             #mobile-collapsible-panel #game-controls > *,
             #mobile-collapsible-panel #translation-controls > *,
             #mobile-collapsible-panel #api-settings > *,
             #mobile-collapsible-panel .api-input-container > *,
             #mobile-collapsible-panel #api-controls > * { width: 100%; margin-top: 10px; margin-left: 0; margin-right: 0; }
             #mobile-collapsible-panel #translation-controls label,
             #mobile-collapsible-panel #api-controls label { width: auto; margin-top: 0; justify-content: flex-start; }
              #mobile-collapsible-panel #api-controls label { margin-bottom: 5px; }
             #mobile-collapsible-panel #test-api-btn { margin-left: 0; }
             #mobile-collapsible-panel #api-settings h4 { margin-top: 0; }
            /* End Mobile Menu & Panel Styles */

            /* Other existing mobile rules */
            #word-display { font-size: 18px; letter-spacing: 3px; min-height: 30px;}
            .letter-button { padding: 7px 8px; min-width: 30px; font-size: 13px;}
            #status { font-size: 14px; }
            #details-popup { width: 95%; padding: 15px; }
            #details-popup h4 { font-size: 1.1em; }
            #details-popup p { font-size: 0.9em; }
        }
        @media (max-width: 420px) {
             #game-container { padding-top: 40px; }
             #game-container-header { margin-top: -40px;}
            .letter-button { min-width: 26px; padding: 6px; font-size: 12px; gap: 3px;}
            #word-display { font-size: 16px; letter-spacing: 2px;}
        }
    </style>
</head>
<body>
    <!-- Canvas -->
    <!-- Game UI -->
    <div id="game-container">
        <button id="mobile-menu-btn">☰</button>
        <h3 id="game-container-header"><span data-translate-key="gameTitle">3D Hangman Game</span></h3>
        <div id="word-display"></div>
        <div id="status-container">
            <span id="status" data-translate-key="statusLoading">Loading Game...</span>
            <span id="word-source"></span>
        </div>
        <div id="used-letters-container">
            <span data-translate-key="usedLettersLabel">Used letters</span>: <span id="used-letters"></span>
        </div>
        <div id="word-details"> <!-- Hidden --> </div>
        <div id="letters-container"></div>
        <div id="mobile-collapsible-panel">
            <div id="game-controls">
                <button id="new-game-btn" data-translate-key="newGame">New Game</button>
                <select id="difficulty-select">
                    <option value="easy" data-translate-key="easyDifficulty">Easy (6 guesses)</option>
                    <option value="medium" selected data-translate-key="mediumDifficulty">Medium (8 guesses)</option>
                    <option value="hard" data-translate-key="hardDifficulty">Hard (10 guesses)</option>
                </select>
            </div>
            <div id="translation-controls">
                <label for="language-select" data-translate-key="languageLabel">Language:</label>
                <select id="language-select"></select>
                <button id="translate-toggle-btn" data-translate-key="translateUI">Translate UI</button>
                <div id="translation-status"></div>
            </div>
            <div id="api-settings">
                 <h4 data-translate-key="aiSettingsTitle">AI Word Generation & Details (Optional)</h4>
                 <div id="api-key-warning" data-translate-key="apiKeyWarning">Note: API key is stored only for this browser session.</div>
                 <div class="api-input-container">
                     <input type="password" id="api-key-input" placeholder="Enter AI API Key" data-translate-key="apiKeyPlaceholder" />
                     <select id="api-model-select">
                         <option value="gemini-1.5-flash">Google Gemini Flash</option>
                         <option value="openai">OpenAI GPT-3.5</option>
                         <option value="anthropic">Anthropic Claude Haiku</option>
                     </select>
                 </div>
                 <div id="api-controls">
                     <label><input type="checkbox" id="use-api-checkbox" /> <span data-translate-key="useAILabel">Use AI</span></label>
                     <button id="test-api-btn" data-translate-key="testApiButton">Test/Save Key</button>
                 </div>
                 <div id="api-status" data-translate-key="apiStatusInitial">Enter key and click Test/Save.</div>
             </div>
        </div>
    </div>
    <!-- Details Popup -->
    <div id="details-popup-overlay">
        <div id="details-popup">
            <h4 id="details-popup-title" data-translate-key="detailsTitle">Word Details</h4>
            <div id="details-popup-content"></div>
            <div id="details-popup-controls">
                <button id="details-popup-ok-btn" data-translate-key="okButton">OK</button>
            </div>
        </div>
    </div>

    <script>
        // Library Waiter
        function waitForLibraries(callback) { /* ... (same) ... */ const maxAttempts = 20; let attempts = 0; function check() { attempts++; console.log(`[Lib Waiter] Attempt ${attempts} to check libraries...`); if (typeof THREE !== 'undefined' && typeof CANNON !== 'undefined' && typeof THREE.OrbitControls !== 'undefined') { console.log("[Lib Waiter] Libraries loaded! Proceeding."); callback(); } else if (attempts >= maxAttempts) { console.error("[Lib Waiter] Libraries did not load after multiple attempts."); const statusEl = document.getElementById('status'); if (statusEl) statusEl.textContent = "Error: Required JavaScript libraries failed to load."; if (typeof THREE === 'undefined') console.error("[Lib Waiter] THREE is missing."); if (typeof CANNON === 'undefined') console.error("[Lib Waiter] CANNON is missing."); if (typeof THREE.OrbitControls === 'undefined') console.error("[Lib Waiter] THREE.OrbitControls is missing."); } else { setTimeout(check, 500); } } check(); }
        window.addEventListener('load', () => waitForLibraries(initHangmanGame));

        // =============================================
        // HANGMAN GAME CODE
        // =============================================
        function initHangmanGame() {
            console.log("Hangman: initHangmanGame() called.");

            // --- Config & State ---
            const HANGMAN_PART_COUNT = { easy: 6, medium: 8, hard: 10 };
            const DEFAULT_WORDS = { easy: ["SKY","PIE","CAT","DOG","SUN","RUN","BALL","TREE","BOOK","CUP","FISH","SHIP","FROG","DUCK","MILK","STAR","HAT","KEY","LAMP","NOTE","APPLE"], medium: ["COMPUTER","KEYBOARD","MONITOR","ELEPHANT","GIRAFFE","STRAWBERRY","PINEAPPLE","WATERMELON","CHOCOLATE","MOUNTAIN","UNIVERSE","TREASURE","JOURNEY","ADVENTURE","KNOWLEDGE","BIRTHDAY","FESTIVAL","VACATION","PAINTING","EXERCISE","BEACH","BRAIN","CHAIR","DANCE","EARTH","FLUTE","GHOST","HOTEL","JUICE","LEMON","MOUSE","NORTH","OCEAN","PANDA","QUEEN","ROBOT","SNAKE","TIGER","UMBRELLA","VOICE","WATCH","XYLOPHONE","YACHT","ZEBRA"], hard: ["ENCYCLOPEDIA","PHOTOSYNTHESIS","EXTRAORDINARY","PERPENDICULAR","REVOLUTIONARY","SOPHISTICATED","PHILOSOPHICAL","CONSTELLATION","BIODIVERSITY","QUINTESSENTIAL","ENTREPRENEURSHIP","EXTRATERRESTRIAL","MULTIDISCIPLINARY","PALEONTOLOGIST","THERMODYNAMICS","CRYPTOCURRENCY","INFRASTRUCTURE","PARLIAMENTARY","BIOTECHNOLOGY","ANTHROPOLOGIST","ADVENTURE","BICYCLE","CHAMPION","DINOSAUR","FIREWORKS","HELICOPTER","INTERNET","JELLYFISH","KANGAROO","LIGHTHOUSE","MAGNIFY","NEIGHBOR","ORCHESTRA","PENGUIN","QUICKSAND","RAINBOW","SPACESHIP","TELESCOPE","UNICORN","VOLCANO","WATERFALL","YESTERDAY","ZODIAC"] };
            const FACE_CHANGE_GUESS_OFFSET = 1;
            let scene, camera, renderer, controls, world;
            let currentWord = "", guessedLetters = [], wrongGuesses = 0, maxWrongGuesses = 8;
            let gameOver = false, animationFrameId;
            let currentDifficulty = "medium", isMobile = false;
            let statusMessage = "Loading...", wordSource = "";
            let gameContainerElement, detailsPopupOverlay, detailsPopupContent, detailsPopupTitle, mobileMenuBtn, mobileCollapsiblePanel;

            // --- NEW: Vertical offset for mobile view ---
            let verticalOffset = 0;

            // API State
            let apiKey = sessionStorage.getItem('hangmanApiKey') || '';
            let apiModel = localStorage.getItem('hangmanApiModel') || 'gemini-1.5-flash';
            let useApiForWords = localStorage.getItem('hangmanUseApi') === 'true';
            let isApiWorking = false;

            // Word History & 3D/Physics
            let previousApiWords = [], MAX_STORED_WORDS = 20;
            let hangmanParts = [], hangmanPhysicsBodies = [];
            let gallows = {}, gallowsBodies = [];
            let groundBody, smileFaceGroup = null, grumpyFaceGroup = null, headMainSphere = null;
            const woodMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8, metalness: 0.2 });
            const ropeMaterial = new THREE.MeshStandardMaterial({ color: 0xBDA580, roughness: 0.9, metalness: 0.1 });
            const skinMaterial = new THREE.MeshStandardMaterial({ color: 0xFFDAB9, roughness: 0.6, metalness: 0.1 });
            const blueMaterial = new THREE.MeshStandardMaterial({ color: 0x4682B4, roughness: 0.7, metalness: 0.1 });
            const blackMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.7, metalness: 0.1 });
            const faceDetailMaterial = new THREE.MeshBasicMaterial({ color: 0x222222, side: THREE.DoubleSide });

            // --- Translation State & Config ---
            const SUPPORTED_LANGUAGES = { 'en': 'English', 'bg': 'Български', 'de': 'Deutsch', 'es': 'Español', 'fr': 'Français' };
            const ORIGINAL_STRINGS = { /* ... (same) ... */ pageTitle: "3D Hangman Game", gameTitle: "3D Hangman Game", statusLoading: "Loading Game...", statusStartingGame: "Starting new game...", statusChoosingWord: "Choosing word...", statusGuess: "Guess a letter! {guessesLeft} guesses left.", statusCorrect: "Correct! '{letter}' is in the word.", statusWrong: "Wrong! '{letter}' not found. {guessesLeft} guesses left.", statusWin: "Congratulations! You guessed \"{word}\"!", statusLoss: "Game Over! The word was \"{word}\".", sourcePrefix: "Source:", usedLettersLabel: "Used letters", detailsTitle: "Details for \"{word}\"", detailsApiNeeded: "API not configured or working - cannot fetch details", detailsInvalidWord: "Invalid word - cannot fetch details", detailsFetching: "Fetching details...", detailsFetchFailed: "Could not fetch details for \"{word}\".", detailsFetchError: "Error fetching details for \"{word}\".", detailsOneExampleOnly: "Only one example sentence found.", wordTranslationLabel: "Translation ({language})", wordTranscriptionLabel: "Transcription", englishContentLabel: "English", translatedContentLabel: "{language}", definitionLabel: "Definition", examplesLabel: "Examples", translationError: "Translation not available", notAvailable: "N/A", okButton: "OK", newGame: "New Game", easyDifficulty: "Easy (6 guesses)", mediumDifficulty: "Medium (8 guesses)", hardDifficulty: "Hard (10 guesses)", languageLabel: "Language:", translateUI: "Translate UI", showOriginal: "Show Original", translationStatusLoading: "Loading translations...", translationStatusError: "Translation failed. Using English.", translationStatusNoAPI: "API needed for translation.", translationStatusSuccess: "{language} translations applied.", aiSettingsTitle: "AI Word Generation & Details (Optional)", apiKeyWarning: "Note: API key is stored only for this browser session.", apiKeyPlaceholder: "Enter AI API Key", useAILabel: "Use AI", testApiButton: "Test/Save Key", apiStatusInitial: "Enter key and click Test/Save.", apiStatusTesting: "Testing {model}...", apiStatusSuccess: "{model} connection successful! Key saved for this session.", apiStatusFailed: "Connection failed: {error}. Check key/model/network.", apiStatusChanged: "API key changed. Please Test/Save.", apiStatusUsingAI: "{model} active this session. Using AI for words/details.", apiStatusUsingDetailsOnly: "{model} active this session. Using AI for details only.", apiStatusNotVerified: "Key entered for {model}, but not verified. Click Test/Save." };
            let isTranslationEnabled = false;
            let currentLanguage = 'en';
            let translationsCache = { 'en': { ...ORIGINAL_STRINGS } };
            let isFetchingTranslation = false;

            // --- Session Storage Helpers ---
            function saveToSessionStorage(key, value) { try { sessionStorage.setItem(key, JSON.stringify(value)); } catch (e) { console.error("Error saving to sessionStorage:", e); } }
            function loadFromSessionStorage(key, defaultValue) { try { const item = sessionStorage.getItem(key); return item ? JSON.parse(item) : defaultValue; } catch (e) { console.error("Error loading from sessionStorage:", e); return defaultValue; } }

            // --- Initialization ---
            function init() {
                console.log("Hangman: init() starting.");
                // Get DOM elements
                gameContainerElement = document.getElementById('game-container');
                detailsPopupOverlay = document.getElementById('details-popup-overlay');
                detailsPopupContent = document.getElementById('details-popup-content');
                detailsPopupTitle = document.getElementById('details-popup-title');
                mobileMenuBtn = document.getElementById('mobile-menu-btn');
                mobileCollapsiblePanel = document.getElementById('mobile-collapsible-panel');
                const okBtn = document.getElementById('details-popup-ok-btn');

                if (!gameContainerElement || !detailsPopupOverlay || !detailsPopupContent || !detailsPopupTitle || !okBtn || !mobileMenuBtn || !mobileCollapsiblePanel) {
                    console.error("Hangman: CRITICAL ERROR - Core UI elements not found!"); updateStatusMessage("Initialization Failed! UI Missing."); return;
                }
                okBtn.addEventListener('click', hideDetailsPopup);

                // Set Difficulty
                const difficultySelect = document.getElementById('difficulty-select');
                if (difficultySelect) { currentDifficulty = difficultySelect.value; maxWrongGuesses = HANGMAN_PART_COUNT[currentDifficulty]; }
                else { console.warn("Difficulty select not found, defaulting to medium."); currentDifficulty = 'medium'; maxWrongGuesses = HANGMAN_PART_COUNT.medium; }

                // Check Mobile & Set Offset
                isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 600;
                verticalOffset = isMobile ? -6 : 0; // Apply vertical offset only on mobile
                console.log(`Mobile = ${isMobile}, Vertical Offset = ${verticalOffset}, Difficulty = ${currentDifficulty}`);

                try {
                    // Setup 3D and Physics FIRST (uses verticalOffset)
                    setupScene();
                    setupPhysics();

                    // --- MODIFIED: Camera/Control Target Adjustment for Mobile ---
                    if (isMobile) {
                        console.log("Mobile detected: Locking controls and adjusting target.");
                        controls.enabled = false; // Lock camera
                        // Look at the new center of the hangman (body center + offset)
                        controls.target.set(0, 0.5 + verticalOffset, 0);
                    }
                    // Update controls AFTER potentially changing target/enabled state
                    controls.update();
                    // --- End Mobile Adjustment ---

                    initUI(); // Setup listeners and UI initial state
                    renderGameState(); // Initial render

                    // Draggable UI (Desktop only)
                    const header = document.getElementById('game-container-header');
                    if (!isMobile && header) { makeDraggable(gameContainerElement, header, document.body); }
                    else if (isMobile && header) { header.style.cursor = 'default'; }

                    // Start Game
                    console.log("Starting first game...");
                    startNewGame().then(() => {
                        console.log("First game setup complete (async).");
                        if (!animationFrameId) { animate(); }
                    }).catch(err => { console.error("Error during initial startNewGame:", err); updateStatusMessage("Error starting game. Check console."); renderGameState(); });
                } catch (error) { /* ... (Error handling) ... */ console.error("CRITICAL ERROR during init() sequence:", error); updateStatusMessage("Initialization Failed! Check console."); wordSource = "(Error)"; gameOver = true; renderGameState(); if(gameContainerElement) { const errorDiv = document.createElement('div'); errorDiv.style.color = 'red'; errorDiv.style.marginTop = '10px'; errorDiv.style.fontWeight = 'bold'; errorDiv.textContent = `Initialization Error: ${error.message}. See console.`; gameContainerElement.appendChild(errorDiv); } }
            }
            function makeDraggable(elmnt, header, boundsElement) { /* ... (same) ... */ if (!elmnt || !header || !boundsElement) { console.warn("Draggable elements or bounds not found"); return; } let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; header.onmousedown = dragMouseDown; function dragMouseDown(e) { e = e || window.event; e.preventDefault(); pos3 = e.clientX; pos4 = e.clientY; document.onmouseup = closeDragElement; document.onmousemove = elementDrag; elmnt.style.opacity = "0.9"; } function elementDrag(e) { e = e || window.event; e.preventDefault(); pos1 = pos3 - e.clientX; pos2 = pos4 - e.clientY; pos3 = e.clientX; pos4 = e.clientY; let newTop = elmnt.offsetTop - pos2; let newLeft = elmnt.offsetLeft - pos1; const elmntWidth = elmnt.offsetWidth; const elmntHeight = elmnt.offsetHeight; const maxTop = boundsElement.clientHeight - elmntHeight; const maxLeft = boundsElement.clientWidth - elmntWidth; newTop = Math.max(0, Math.min(newTop, maxTop < 0 ? 0 : maxTop)); newLeft = Math.max(0, Math.min(newLeft, maxLeft < 0 ? 0 : maxLeft)); elmnt.style.top = newTop + "px"; elmnt.style.left = newLeft + "px"; } function closeDragElement() { document.onmouseup = null; document.onmousemove = null; elmnt.style.opacity = "1"; } }
            function initUI() { /* ... (same, including mobile menu listener) ... */ apiKey = sessionStorage.getItem('hangmanApiKey') || ''; const storedModel = localStorage.getItem('hangmanApiModel'); if (storedModel && ['gemini-1.5-flash', 'openai', 'anthropic'].includes(storedModel)) { apiModel = storedModel; } else { apiModel = 'gemini-1.5-flash'; localStorage.setItem('hangmanApiModel', apiModel); } useApiForWords = localStorage.getItem('hangmanUseApi') === 'true'; const apiKeyInput = document.getElementById('api-key-input'); const apiModelSelect = document.getElementById('api-model-select'); const useApiCheckbox = document.getElementById('use-api-checkbox'); const newGameBtn = document.getElementById('new-game-btn'); const difficultySelect = document.getElementById('difficulty-select'); const testApiBtn = document.getElementById('test-api-btn'); const languageSelect = document.getElementById('language-select'); const translateToggleBtn = document.getElementById('translate-toggle-btn'); if (apiKeyInput) apiKeyInput.value = apiKey; if (apiModelSelect) apiModelSelect.value = apiModel; if (useApiCheckbox) useApiCheckbox.checked = useApiForWords; if (difficultySelect) difficultySelect.value = currentDifficulty; updateApiStatusDisplay(); if (newGameBtn) newGameBtn.addEventListener('click', startNewGame); if (testApiBtn) testApiBtn.addEventListener('click', testAndSaveApiSettings); if (useApiCheckbox) useApiCheckbox.addEventListener('change', function() { useApiForWords = this.checked; localStorage.setItem('hangmanUseApi', useApiForWords); updateApiStatusDisplay(); if (useApiForWords && !isApiWorking && apiKey) { updateApiStatusDisplay("apiStatusChanged"); } }); if (apiKeyInput) apiKeyInput.addEventListener('input', () => { apiKey = apiKeyInput.value.trim(); isApiWorking = false; updateApiStatusDisplay("apiStatusChanged"); }); if (difficultySelect) difficultySelect.addEventListener('change', () => { currentDifficulty = difficultySelect.value; maxWrongGuesses = HANGMAN_PART_COUNT[currentDifficulty]; console.log('Difficulty changed to ' + currentDifficulty + ', Max Guesses: ' + maxWrongGuesses); }); if (apiModelSelect) apiModelSelect.addEventListener('change', function() { apiModel = this.value; localStorage.setItem('hangmanApiModel', apiModel); isApiWorking = false; updateApiStatusDisplay(); }); if (mobileMenuBtn) { mobileMenuBtn.addEventListener('click', () => { if (mobileCollapsiblePanel) { mobileCollapsiblePanel.classList.toggle('panel-visible'); mobileMenuBtn.textContent = mobileCollapsiblePanel.classList.contains('panel-visible') ? '✕' : '☰'; } }); } isTranslationEnabled = loadFromSessionStorage('hangmanTranslationEnabled', false); currentLanguage = loadFromSessionStorage('hangmanCurrentLanguage', 'en'); translationsCache = loadFromSessionStorage('hangmanTranslationsCache', { 'en': { ...ORIGINAL_STRINGS } }); if (!SUPPORTED_LANGUAGES[currentLanguage]) { currentLanguage = 'en'; saveToSessionStorage('hangmanCurrentLanguage', currentLanguage); } if (!translationsCache['en']) { translationsCache['en'] = { ...ORIGINAL_STRINGS }; saveToSessionStorage('hangmanTranslationsCache', translationsCache); } if (languageSelect) { languageSelect.innerHTML = ''; Object.entries(SUPPORTED_LANGUAGES).forEach(([code, name]) => { const option = document.createElement('option'); option.value = code; option.textContent = name; if (code === currentLanguage) { option.selected = true; } languageSelect.appendChild(option); }); languageSelect.addEventListener('change', (event) => changeLanguage(event.target.value)); } if (translateToggleBtn) { translateToggleBtn.addEventListener('click', toggleTranslation); updateToggleButtonState(); } if (isTranslationEnabled && currentLanguage !== 'en') { applyTranslation(); } else { revertToOriginal(); } updateTranslationStatus(); setupKeyboardControls(); }

            // --- Scene & Physics Setup ---
            // MODIFIED: setupScene adjusted for mobile camera position/lookAt
            function setupScene() {
                 console.log("Hangman: setupScene() starting...");
                 try {
                     scene = new THREE.Scene();
                     scene.background = new THREE.Color(0x87CEEB);
                     const containerWidth = window.innerWidth;
                     const containerHeight = window.innerHeight;
                     console.log(`Window dimensions: ${containerWidth}x${containerHeight}`);
                     if (containerWidth <= 0 || containerHeight <= 0) { console.warn("Window has zero dimensions on setup!"); }

                     camera = new THREE.PerspectiveCamera(70, containerWidth / Math.max(containerHeight, 1), 0.1, 1000);

                     // --- Camera Position/LookAt based on Mobile ---
                     if (isMobile) {
                         camera.position.set(0, verticalOffset + 1, 13); // Lower and slightly back
                         camera.lookAt(0, 0.5 + verticalOffset, 0);     // Look lower
                         console.log("Mobile camera initial pos/lookAt adjusted.");
                     } else {
                         camera.position.set(0, 1, 12); // Default desktop position
                         camera.lookAt(0, 1, 0);     // Default desktop lookAt
                     }
                     // --- End Adjustment ---

                     renderer = new THREE.WebGLRenderer({ antialias: !isMobile, powerPreference: "high-performance", alpha: false });
                     renderer.setSize(containerWidth, containerHeight);
                     renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2));
                     renderer.shadowMap.enabled = !isMobile; if (!isMobile) { renderer.shadowMap.type = THREE.PCFSoftShadowMap; }
                     document.body.appendChild(renderer.domElement);

                     // Lights (same)
                     const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); scene.add(ambientLight);
                     const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); directionalLight.position.set(8, 15, 10); directionalLight.castShadow = !isMobile; if (!isMobile) { /*... shadow settings ...*/ directionalLight.shadow.mapSize.width = 1024; directionalLight.shadow.mapSize.height = 1024; directionalLight.shadow.camera.near = 1; directionalLight.shadow.camera.far = 50; directionalLight.shadow.camera.left = -15; directionalLight.shadow.camera.right = 15; directionalLight.shadow.camera.top = 15; directionalLight.shadow.camera.bottom = -15; } scene.add(directionalLight);

                     // Ground (position adjusted in setupPhysics now)
                     const groundGeometry = new THREE.PlaneGeometry(100, 100); const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x90EE90, roughness: 0.9, metalness: 0.1 }); const ground = new THREE.Mesh(groundGeometry, groundMaterial); ground.rotation.x = -Math.PI / 2; ground.position.y = -4.5 + verticalOffset; /* Use offset here too for visual consistency */ ground.receiveShadow = !isMobile; scene.add(ground);

                     // OrbitControls (target adjusted in init() for mobile)
                     controls = new THREE.OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.dampingFactor = 0.05; controls.minDistance = 4; controls.maxDistance = 30; controls.maxPolarAngle = Math.PI / 2 - 0.05;
                     // Default target set here, overridden in init() for mobile
                     controls.target.set(0, 1, 0);

                     window.addEventListener('resize', onCanvasContainerResize); console.log("Scene setup finished.");
                 } catch (error) { console.error("Error during setupScene:", error); throw error; }
            }
            // MODIFIED: setupPhysics adjusts ground position
            function setupPhysics() {
                 console.log("Hangman: setupPhysics() starting...");
                 try {
                     world = new CANNON.World(); world.gravity.set(0, -9.82, 0); world.broadphase = new CANNON.NaiveBroadphase(); world.solver.iterations = 10; world.allowSleep = true;
                     const groundShape = new CANNON.Plane();
                     groundBody = new CANNON.Body({ mass: 0, shape: groundShape });
                     groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
                     groundBody.position.set(0, -4.5 + verticalOffset, 0); // Apply offset
                     world.addBody(groundBody);
                     console.log("Physics world created. Ground Y:", groundBody.position.y);
                 } catch (error) { console.error("Error during setupPhysics:", error); throw error; }
            }

            // --- Gallows & Hangman Creation ---
            // MODIFIED: createGallows applies verticalOffset
            function createGallows() {
                 console.log("Creating gallows...");
                 try {
                     Object.values(gallows).forEach(mesh => { if (mesh && mesh.parent) mesh.parent.remove(mesh); });
                     gallows = { base: null, pole: null, beam: null, support: null, rope: null };
                     gallowsBodies.forEach(body => { if (body.world) world.remove(body); }); gallowsBodies = [];

                     const basePos = { x: 0, y: -4.1 + verticalOffset, z: 0 };
                     const polePos = { x: -2.5, y: 0 + verticalOffset, z: 0 };
                     const beamPos = { x: -0.25, y: 4.0 + verticalOffset, z: 0 };
                     const supportPos = { x: -1.5, y: 2.5 + verticalOffset, z: 0 };
                     const ropePos = { x: 1.7, y: 3.1 + verticalOffset, z: 0 };

                     const baseGeo = new THREE.BoxGeometry(6, 0.8, 2); gallows.base = new THREE.Mesh(baseGeo, woodMaterial); gallows.base.position.set(basePos.x, basePos.y, basePos.z); gallows.base.castShadow = !isMobile; gallows.base.receiveShadow = !isMobile; scene.add(gallows.base);
                     const poleGeo = new THREE.BoxGeometry(0.8, 8, 0.8); gallows.pole = new THREE.Mesh(poleGeo, woodMaterial); gallows.pole.position.set(polePos.x, polePos.y, polePos.z); gallows.pole.castShadow = !isMobile; gallows.pole.receiveShadow = !isMobile; scene.add(gallows.pole);
                     const beamGeo = new THREE.BoxGeometry(4.5, 0.8, 0.8); gallows.beam = new THREE.Mesh(beamGeo, woodMaterial); gallows.beam.position.set(beamPos.x, beamPos.y, beamPos.z); gallows.beam.castShadow = !isMobile; gallows.beam.receiveShadow = !isMobile; scene.add(gallows.beam);
                     const supportGeo = new THREE.BoxGeometry(3.5, 0.6, 0.6); gallows.support = new THREE.Mesh(supportGeo, woodMaterial); gallows.support.position.set(supportPos.x, supportPos.y, supportPos.z); gallows.support.rotation.z = Math.PI / 4; gallows.support.castShadow = !isMobile; gallows.support.receiveShadow = !isMobile; scene.add(gallows.support);
                     const ropeGeo = new THREE.CylinderGeometry(0.08, 0.08, 1.8, 8); gallows.rope = new THREE.Mesh(ropeGeo, ropeMaterial); gallows.rope.position.set(ropePos.x, ropePos.y, ropePos.z); gallows.rope.castShadow = !isMobile; scene.add(gallows.rope);

                     const addStaticBody = (shape, position) => { const body = new CANNON.Body({ mass: 0, shape }); body.position.copy(position); world.addBody(body); gallowsBodies.push(body); };
                     addStaticBody(new CANNON.Box(new CANNON.Vec3(3, 0.4, 1)), new CANNON.Vec3(basePos.x, basePos.y, basePos.z));
                     addStaticBody(new CANNON.Box(new CANNON.Vec3(0.4, 4, 0.4)), new CANNON.Vec3(polePos.x, polePos.y, polePos.z));
                     addStaticBody(new CANNON.Box(new CANNON.Vec3(2.25, 0.4, 0.4)), new CANNON.Vec3(beamPos.x, beamPos.y, beamPos.z));

                     console.log("Gallows created with offset:", verticalOffset);
                 } catch (error) { console.error("Error during createGallows:", error); }
            }
            // MODIFIED: createHangmanParts applies verticalOffset
            function createHangmanParts() {
                 console.log("Creating hangman parts...");
                 try {
                     hangmanParts.forEach(part => { if (part.mesh && part.mesh.parent) part.mesh.parent.remove(part.mesh); });
                     hangmanPhysicsBodies.forEach(item => { if (item.body && item.body.world) world.remove(item.body); });
                     hangmanParts = []; hangmanPhysicsBodies = []; smileFaceGroup = null; grumpyFaceGroup = null; headMainSphere = null;
                     const partsToCreate = HANGMAN_PART_COUNT[currentDifficulty] || 0; if (partsToCreate <= 0) { console.warn("No hangman parts to create."); return; }

                     const headBaseX = 1.7; const headBaseY = 1.7 + verticalOffset; const headBaseZ = 0; // Apply offset here

                     smileFaceGroup = new THREE.Group(); smileFaceGroup.visible = false; /* ... face details ... */ const eyeRadius = 0.15; const eyeY = 0.1; const eyeZ = 0.48; const smileEyeGeo = new THREE.SphereGeometry(0.06, 12, 8); const smileLeftEye = new THREE.Mesh(smileEyeGeo, faceDetailMaterial); smileLeftEye.position.set(-eyeRadius, eyeY, eyeZ); smileFaceGroup.add(smileLeftEye); const smileRightEye = new THREE.Mesh(smileEyeGeo, faceDetailMaterial); smileRightEye.position.set(eyeRadius, eyeY, eyeZ); smileFaceGroup.add(smileRightEye); const smileGeo = new THREE.TorusGeometry(0.2, 0.03, 8, 16, Math.PI); const smileMouth = new THREE.Mesh(smileGeo, faceDetailMaterial); smileMouth.position.set(0, -0.15, eyeZ - 0.02); smileMouth.rotation.z = Math.PI; smileFaceGroup.add(smileMouth);
                     grumpyFaceGroup = new THREE.Group(); grumpyFaceGroup.visible = false; /* ... face details ... */ const crossSize = 0.35; const crossThickness = 0.03; const eyeX = 0.20; const eyeYGrumpy = 0.1; const eyeZGrumpy = 0.45; const crossGeo = new THREE.CylinderGeometry(crossThickness, crossThickness, crossSize, 6); const l_eye1 = new THREE.Mesh(crossGeo, faceDetailMaterial); l_eye1.position.set(-eyeX, eyeYGrumpy, eyeZGrumpy); l_eye1.rotation.z = Math.PI / 4; grumpyFaceGroup.add(l_eye1); const l_eye2 = new THREE.Mesh(crossGeo, faceDetailMaterial); l_eye2.position.set(-eyeX, eyeYGrumpy, eyeZGrumpy); l_eye2.rotation.z = -Math.PI / 4; grumpyFaceGroup.add(l_eye2); const r_eye1 = new THREE.Mesh(crossGeo, faceDetailMaterial); r_eye1.position.set(eyeX, eyeYGrumpy, eyeZGrumpy); r_eye1.rotation.z = Math.PI / 4; grumpyFaceGroup.add(r_eye1); const r_eye2 = new THREE.Mesh(crossGeo, faceDetailMaterial); r_eye2.position.set(eyeX, eyeYGrumpy, eyeZGrumpy); r_eye2.rotation.z = -Math.PI / 4; grumpyFaceGroup.add(r_eye2); const grumpyMouthGeo = new THREE.BoxGeometry(0.4, 0.05, 0.05); const grumpyMouth = new THREE.Mesh(grumpyMouthGeo, faceDetailMaterial); grumpyMouth.position.set(0, -0.18, eyeZGrumpy + 0.03); grumpyFaceGroup.add(grumpyMouth);

                     // Apply verticalOffset to Y positions
                     const partDefinitions = [
                         { name: "head", geo: new THREE.SphereGeometry(0.5, 24, 18), mat: skinMaterial, pos: [headBaseX, headBaseY, headBaseZ], physShape: new CANNON.Sphere(0.5), mass: 3 },
                         { name: "body", geo: new THREE.BoxGeometry(0.9, 1.4, 0.5), mat: blueMaterial, pos: [1.7, 0.5 + verticalOffset, 0], physShape: new CANNON.Box(new CANNON.Vec3(0.45, 0.7, 0.25)), mass: 6 },
                         { name: "l_arm", geo: new THREE.BoxGeometry(0.8, 0.3, 0.3), mat: blueMaterial, pos: [1.0, 0.9 + verticalOffset, 0], rot: [0, 0, 0.3], physShape: new CANNON.Box(new CANNON.Vec3(0.4, 0.15, 0.15)), mass: 1 },
                         { name: "r_arm", geo: new THREE.BoxGeometry(0.8, 0.3, 0.3), mat: blueMaterial, pos: [2.4, 0.9 + verticalOffset, 0], rot: [0, 0, -0.3], physShape: new CANNON.Box(new CANNON.Vec3(0.4, 0.15, 0.15)), mass: 1 },
                         { name: "l_leg", geo: new THREE.BoxGeometry(0.3, 0.9, 0.3), mat: blackMaterial, pos: [1.45, -0.4 + verticalOffset, 0], physShape: new CANNON.Box(new CANNON.Vec3(0.15, 0.45, 0.15)), mass: 2 },
                         { name: "r_leg", geo: new THREE.BoxGeometry(0.3, 0.9, 0.3), mat: blackMaterial, pos: [1.95, -0.4 + verticalOffset, 0], physShape: new CANNON.Box(new CANNON.Vec3(0.15, 0.45, 0.15)), mass: 2 },
                         { name: "l_foot", geo: new THREE.BoxGeometry(0.35, 0.2, 0.45), mat: blackMaterial, pos: [1.45, -0.9 + verticalOffset, 0.05], physShape: new CANNON.Box(new CANNON.Vec3(0.175, 0.1, 0.225)), mass: 0.5 },
                         { name: "r_foot", geo: new THREE.BoxGeometry(0.35, 0.2, 0.45), mat: blackMaterial, pos: [1.95, -0.9 + verticalOffset, 0.05], physShape: new CANNON.Box(new CANNON.Vec3(0.175, 0.1, 0.225)), mass: 0.5 },
                         { name: "hat", geo: new THREE.CylinderGeometry(0.3, 0.4, 0.3, 16), mat: blackMaterial, pos: [1.7, 2.25 + verticalOffset, 0], physShape: new CANNON.Cylinder(0.3, 0.4, 0.3, 8), mass: 0.5 }
                     ];
                     for (let i = 0; i < partsToCreate; i++) {
                         /* ... (mesh/body creation using the offset positions) ... */ if (i >= partDefinitions.length) { console.log(`Ran out of part definitions at index ${i}`); hangmanParts.push({ mesh: null }); continue; } const def = partDefinitions[i]; if (!def) { console.warn(`Part definition missing for index ${i}`); hangmanParts.push({ mesh: null }); continue; } const mesh = new THREE.Mesh(def.geo, def.mat); mesh.position.set(...def.pos); if (def.rot) mesh.rotation.set(...def.rot); mesh.castShadow = !isMobile; mesh.visible = false; mesh.name = def.name; scene.add(mesh); if (def.name === "head") { headMainSphere = mesh; mesh.add(smileFaceGroup); mesh.add(grumpyFaceGroup); console.log("Added faces to head mesh."); } const body = new CANNON.Body({ mass: def.mass, shape: def.physShape, position: new CANNON.Vec3(...def.pos), linearDamping: 0.2, angularDamping: 0.2 }); if(def.rot) { const euler = new THREE.Euler(...def.rot, 'XYZ'); body.quaternion.setFromEuler(euler.x, euler.y, euler.z, 'XYZ'); } body.name = def.name; body.allowSleep = true; body.sleep(); hangmanPhysicsBodies.push({ mesh: mesh, body: body }); hangmanParts.push({ mesh: mesh });
                     } console.log(`Finished creating ${hangmanParts.length} part entries with offset:`, verticalOffset);
                 } catch (error) { console.error("Error during createHangmanParts:", error); }
            }

            // --- UI Updates ---
            function renderGameState() { /* ... (same) ... */ applyStaticTranslations(); try { updateStatusMessage(statusMessage); const sourceEl = document.getElementById('word-source'); if (sourceEl) { sourceEl.textContent = wordSource ? `(${getTranslation('sourcePrefix')} ${wordSource})` : ''; } const wordDisplayEl = document.getElementById('word-display'); if (wordDisplayEl) { if (currentWord && currentWord !== "ERROR") { const display = currentWord.split('').map(letter => (guessedLetters.includes(letter) || gameOver) ? letter : '_').join(''); wordDisplayEl.textContent = display.split('').join(' '); } else if (currentWord === "ERROR") { wordDisplayEl.textContent = "E R R O R"; } else { wordDisplayEl.textContent = ""; } } const usedLettersEl = document.getElementById('used-letters'); if (usedLettersEl) { usedLettersEl.textContent = guessedLetters.sort().join(', '); } createLetterButtons(); updateApiStatusDisplay(); updateTranslationStatus(); updateToggleButtonState(); } catch (uiError) { console.error("Error updating UI:", uiError); updateStatusMessage("UI Update Error!"); } }
            function updateStatusMessage(newMessageOrKey, params = {}) { /* ... (same) ... */ let messageText = newMessageOrKey; const statusEl = document.getElementById('status'); if (!statusEl) return; if (ORIGINAL_STRINGS[newMessageOrKey]) { messageText = getTranslation(newMessageOrKey, null, params); statusMessage = messageText; statusEl.textContent = messageText; } else { statusMessage = newMessageOrKey; statusEl.textContent = newMessageOrKey; } }
            function createLetterButtons() { /* ... (same) ... */ const container = document.getElementById('letters-container'); if (!container) return; container.innerHTML = ''; if (!currentWord || currentWord === "ERROR" || statusMessage === getTranslation('statusLoading') || statusMessage === getTranslation('statusStartingGame') || statusMessage === getTranslation('statusChoosingWord') || statusMessage.includes('Getting')) { return; } for (let i = 65; i <= 90; i++) { const letter = String.fromCharCode(i); const button = document.createElement('button'); button.textContent = letter; button.className = 'letter-button'; button.dataset.letter = letter; const isGuessed = guessedLetters.includes(letter); button.disabled = gameOver || isGuessed; button.classList.toggle('disabled', button.disabled); if (isGuessed) { const correct = currentWord.includes(letter); button.classList.toggle('correct', correct); button.classList.toggle('incorrect', !correct); } button.addEventListener('click', () => handleGuess(letter)); container.appendChild(button); } }

            // --- Game Logic ---
            async function startNewGame() { /* ... (same) ... */ console.log(`--- Start New Game --- Difficulty: ${currentDifficulty}`); gameOver = false; wrongGuesses = 0; guessedLetters = []; currentWord = ""; wordSource = ""; hideDetailsPopup(); updateStatusMessage('statusStartingGame'); renderGameState(); try { console.log("Resetting physics bodies..."); hangmanPhysicsBodies.forEach(item => { if (item?.body?.world) world.remove(item.body); }); gallowsBodies.forEach(body => { if (body?.world) world.remove(body); }); hangmanPhysicsBodies = []; gallowsBodies = []; console.log("Physics bodies removed."); createGallows(); createHangmanParts(); console.log("Visual elements recreated."); } catch (resetError) { console.error("Error resetting scene/physics:", resetError); updateStatusMessage("Error resetting game visuals! Check console."); wordSource = "(Error)"; currentWord = "ERROR"; gameOver = true; renderGameState(); if (!animationFrameId) animate(); return; } try { let word = null; let apiAttempted = false; updateStatusMessage('statusChoosingWord'); renderGameState(); if (useApiForWords && isApiWorking) { apiAttempted = true; const friendlyModelName = getFriendlyApiModelName(apiModel); updateStatusMessage(`Getting ${currentDifficulty} word from ${friendlyModelName}...`); renderGameState(); word = await getWordFromApi(); if (word) { console.log("API Success:", word); wordSource = 'AI'; } else { console.warn("API failed/invalid/duplicate. Falling back."); updateStatusMessage(`AI failed. Using local ${currentDifficulty} word...`); wordSource = 'Local'; renderGameState(); } } if (!word) { if (!apiAttempted) { console.log(`Using local ${currentDifficulty} word list.`); wordSource = 'Local'; updateStatusMessage(`Using local ${currentDifficulty} word...`); renderGameState(); } else { console.log(`Fell back to local ${currentDifficulty} word list.`); } const words = DEFAULT_WORDS[currentDifficulty]; if (!words || words.length === 0) throw new Error(`No local words for ${currentDifficulty}`); word = words[Math.floor(Math.random() * words.length)]; console.log("Selected local word:", word); if (!wordSource) wordSource = 'Local'; } currentWord = word.toUpperCase(); updateStatusMessage('statusGuess', { guessesLeft: maxWrongGuesses - wrongGuesses }); console.log(`Final Word: "${currentWord}", Source: ${wordSource}`); } catch (error) { console.error("CRITICAL error getting word:", error); updateStatusMessage(`Error: ${error.message}. Try New Game.`); wordSource = '(Error)'; currentWord = "ERROR"; gameOver = true; } finally { renderGameState(); console.log("--- End New Game ---"); } }
            function handleGuess(letter) { /* ... (same) ... */ if (gameOver || guessedLetters.includes(letter) || !currentWord || currentWord === "ERROR") return; guessedLetters.push(letter); if (currentWord.includes(letter)) { updateStatusMessage('statusCorrect', { letter: letter }); checkWinCondition(); } else { wrongGuesses++; updateStatusMessage('statusWrong', { letter: letter, guessesLeft: maxWrongGuesses - wrongGuesses }); revealHangmanPart(); checkLossCondition(); } renderGameState(); }
            function revealHangmanPart() { /* ... (same) ... */ if (wrongGuesses <= 0 || wrongGuesses > hangmanParts.length) { console.warn(`Invalid wrongGuesses (${wrongGuesses}) or index out of bounds (${hangmanParts.length})`); return; } const partIndex = wrongGuesses - 1; console.log(`Revealing part index ${partIndex} (Wrong Guesses: ${wrongGuesses})`); const part = hangmanParts[partIndex]; if (part && part.mesh) { const partMesh = part.mesh; if (!partMesh.visible) { console.log(`Making mesh "${partMesh.name}" visible.`); partMesh.visible = true; if (partIndex === 0 && headMainSphere) { if(smileFaceGroup) smileFaceGroup.visible = true; if(grumpyFaceGroup) grumpyFaceGroup.visible = false; console.log("Revealed head, showing smile face."); } const originalScale = partMesh.scale.clone(); partMesh.scale.set(1.3, 1.3, 1.3); let startTime = performance.now(); function scaleDown() { if (!partMesh || !partMesh.parent) return; const elapsed = performance.now() - startTime; const progress = Math.min(elapsed / 150, 1); const scale = 1.3 - 0.3 * progress; partMesh.scale.set(scale, scale, scale); if (progress < 1) { requestAnimationFrame(scaleDown); } else { partMesh.scale.copy(originalScale); } } requestAnimationFrame(scaleDown); } else { console.log(`Part mesh "${partMesh.name}" at index ${partIndex} was already visible.`); } } else { console.warn(`Attempted to reveal part index ${partIndex}, but part or mesh was missing/null.`); } if (currentDifficulty === 'hard' && wrongGuesses === maxWrongGuesses - FACE_CHANGE_GUESS_OFFSET) { if (smileFaceGroup && grumpyFaceGroup && headMainSphere && headMainSphere.visible) { smileFaceGroup.visible = false; grumpyFaceGroup.visible = true; console.log("Switched to grumpy face for hard mode nearing end."); } } }
            function checkWinCondition() { /* ... (same) ... */ if (!currentWord || gameOver) return; if (currentWord.split('').every(char => guessedLetters.includes(char))) { updateStatusMessage('statusWin', { word: currentWord }); gameOver = true; renderGameState(); console.log("--- Game Won ---"); triggerFetchAndDisplayWordDetails(currentWord); } }
            function checkLossCondition() { /* ... (same) ... */ if (gameOver) return; if (wrongGuesses >= maxWrongGuesses) { updateStatusMessage('statusLoss', { word: currentWord }); gameOver = true; renderGameState(); console.log("--- Game Lost --- Activating Physics"); activateHangmanPhysics(); triggerFetchAndDisplayWordDetails(currentWord); } }
            function activateHangmanPhysics() { /* ... (same, uses offset positions from creation) ... */ console.log("--- Activating Physics ---"); if (!world) { console.error("Cannot activate physics, world not initialized."); return; } if (gallows.rope && gallows.rope.parent) { scene.remove(gallows.rope); gallows.rope = null; console.log("Removed visual rope."); } const tempWorldPos = new THREE.Vector3(); const tempWorldQuat = new THREE.Quaternion(); let physicsActivatedCount = 0; hangmanPhysicsBodies.forEach((item, index) => { if (!item?.body || !item?.mesh) { console.warn(`Skipping physics activation for item ${index}, body or mesh missing.`); return; } const meshName = item.mesh.name || `mesh_${index}`; if(!item.mesh.visible) { console.warn(`Physics body mesh ${meshName} is not visible! Making it visible.`); item.mesh.visible = true; } if (item.mesh === headMainSphere) { if (smileFaceGroup) smileFaceGroup.visible = (currentDifficulty !== 'hard'); if (grumpyFaceGroup) grumpyFaceGroup.visible = (currentDifficulty === 'hard'); } if (!item.body.world) { try { world.addBody(item.body); physicsActivatedCount++; } catch (addError) { console.error(`ERROR adding body ${meshName} to world:`, addError); return; } } item.body.sleepState = CANNON.Body.AWAKE; item.body.velocity.set(0,0,0); item.body.angularVelocity.set(0,0,0); item.body.force.set(0,0,0); item.body.torque.set(0,0,0); try { item.mesh.getWorldPosition(tempWorldPos); item.body.position.copy(tempWorldPos); item.mesh.getWorldQuaternion(tempWorldQuat); item.body.quaternion.copy(tempWorldQuat); const impulseStrength = 1.5 + Math.random() * 1.0; const randomVec = new CANNON.Vec3( (Math.random() - 0.5) * impulseStrength, (Math.random() - 0.8) * impulseStrength, (Math.random() - 0.5) * impulseStrength ); const point = new CANNON.Vec3( (Math.random() - 0.5) * 0.2, (Math.random() - 0.5) * 0.2, (Math.random() - 0.5) * 0.2 ); item.body.applyImpulse(randomVec, point); item.body.angularVelocity.set( (Math.random() - 0.5) * 6, (Math.random() - 0.5) * 6, (Math.random() - 0.5) * 6 ); } catch (syncError) { console.error(`Error syncing/applying impulse to body ${meshName}:`, syncError); } }); if (physicsActivatedCount === 0 && hangmanPhysicsBodies.length > 0) { console.warn("No new physics bodies were added during activation."); } else if (hangmanPhysicsBodies.length === 0) { console.warn("No hangman physics bodies found to activate."); } console.log(`--- Finished Activating Physics (${physicsActivatedCount} bodies added/woken) ---`); }

             // --- Details Popup & Fetching ---
             function triggerFetchAndDisplayWordDetails(word) { /* ... (same) ... */ if (!isApiWorking || !apiKey) { showDetailsPopup(word, { error: getTranslation('detailsApiNeeded') }); return; } if (!word || word === "ERROR") { showDetailsPopup(word, { error: getTranslation('detailsInvalidWord') }); return; } showDetailsPopup(word, { loading: true }); console.log(`Fetching details for "${word}" (Lang: ${currentLanguage}) using ${apiModel}`); fetchBilingualWordDetails(word, currentLanguage).then(details => { if (details && !details.error) { showDetailsPopup(word, details); } else { const errorMsg = details?.error || getTranslation('detailsFetchFailed', null, { word: word }); showDetailsPopup(word, { error: errorMsg }); console.warn(`Failed to get details object for "${word}". Error: ${errorMsg}`); } }).catch(error => { console.error(`Error fetching word details for "${word}":`, error); showDetailsPopup(word, { error: getTranslation('detailsFetchError', null, { word: word }) }); }); }
             function showDetailsPopup(word, details) { /* ... (same) ... */ if (!detailsPopupOverlay || !detailsPopupContent || !detailsPopupTitle) return; detailsPopupTitle.textContent = getTranslation('detailsTitle', 'Details for "{word}"', { word: word }); const okBtn = document.getElementById('details-popup-ok-btn'); if (okBtn) okBtn.textContent = getTranslation('okButton', 'OK'); let contentHtml = ''; if (details.loading) { contentHtml = `<p>${getTranslation('detailsFetching', 'Fetching details...')}</p>`; } else if (details.error) { contentHtml = `<p class="error">${details.error}</p>`; } else { const targetLangName = SUPPORTED_LANGUAGES[currentLanguage] || currentLanguage; const isTargetEnglish = currentLanguage === 'en'; const hasTranslationData = !isTargetEnglish && details.translation; if (hasTranslationData) { contentHtml += `<div class="word-translation-block">`; if (details.translation.wordTranslation) { contentHtml += `<span class="word-translation"><strong>${getTranslation('wordTranslationLabel', 'Translation ({language})', { language: targetLangName })}:</strong> ${details.translation.wordTranslation}</span>`; } else { contentHtml += `<span class="word-translation error"><strong>${getTranslation('wordTranslationLabel', 'Translation ({language})', { language: targetLangName })}:</strong> ${getTranslation('translationError', 'Translation not available')}</span>`; } if (details.translation.wordTranscription) { contentHtml += `<span class="word-transcription">(${getTranslation('wordTranscriptionLabel', 'Transcription')}: ${details.translation.wordTranscription})</span>`; } contentHtml += `</div>`; } contentHtml += `<h5>${getTranslation('englishContentLabel', 'English')}</h5>`; if (details.english?.definition) { contentHtml += `<p><strong>${getTranslation('definitionLabel', 'Definition')}:</strong> ${details.english.definition}</p>`; } else { contentHtml += `<p><strong>${getTranslation('definitionLabel', 'Definition')}:</strong> <span class="error">${getTranslation('notAvailable', 'N/A')}</span></p>`; } if (details.english?.examples && details.english.examples.length > 0) { contentHtml += `<p><strong>${getTranslation('examplesLabel', 'Examples')}:</strong></p>`; details.english.examples.forEach((ex, i) => { if (ex) contentHtml += `<p style="margin-left: 15px;">${i + 1}. ${ex}</p>`; }); } else { contentHtml += `<p><strong>${getTranslation('examplesLabel', 'Examples')}:</strong> <span class="error">${getTranslation('notAvailable', 'N/A')}</span></p>`; } if (hasTranslationData) { contentHtml += `<div class="section-separator"></div>`; contentHtml += `<h5>${getTranslation('translatedContentLabel', '{language}', { language: targetLangName })}</h5>`; if (details.translation?.definition) { contentHtml += `<p><strong>${getTranslation('definitionLabel', 'Definition')}:</strong> ${details.translation.definition}</p>`; } else { contentHtml += `<p><strong>${getTranslation('definitionLabel', 'Definition')}:</strong> <span class="error">${getTranslation('translationError', 'Translation not available')}</span></p>`; } if (details.translation?.examples && details.translation.examples.length > 0) { contentHtml += `<p><strong>${getTranslation('examplesLabel', 'Examples')}:</strong></p>`; details.translation.examples.forEach((ex, i) => { if (ex) contentHtml += `<p style="margin-left: 15px;">${i + 1}. ${ex}</p>`; }); if (details.translation.examples.length === 1 && details.english?.examples?.length === 2) { contentHtml += `<p><em>(${getTranslation('detailsOneExampleOnly', 'Only one example sentence found.')})</em></p>`; } } else { contentHtml += `<p><strong>${getTranslation('examplesLabel', 'Examples')}:</strong> <span class="error">${getTranslation('translationError', 'Translation not available')}</span></p>`; } } } detailsPopupContent.innerHTML = contentHtml; detailsPopupOverlay.style.display = 'flex'; }
             function hideDetailsPopup() { /* ... (same) ... */ if (detailsPopupOverlay) { detailsPopupOverlay.style.display = 'none'; } }

            // --- API Integration ---
            function getFriendlyApiModelName(modelId) { /* ... (same) ... */ switch(modelId) { case 'gemini-1.5-flash': return 'Google Gemini Flash'; case 'openai': return 'OpenAI GPT-3.5'; case 'anthropic': return 'Anthropic Claude Haiku'; default: return modelId; } }
            async function testAndSaveApiSettings() { /* ... (same) ... */ apiKey = document.getElementById('api-key-input')?.value.trim() || ''; apiModel = document.getElementById('api-model-select')?.value || 'gemini-1.5-flash'; const friendlyModelName = getFriendlyApiModelName(apiModel); if (!apiKey) { updateApiStatusDisplay("Please enter an API key.", 'orange'); isApiWorking = false; sessionStorage.removeItem('hangmanApiKey'); if (isTranslationEnabled && currentLanguage !== 'en') updateTranslationStatus(); return; } updateApiStatusDisplay('apiStatusTesting', { model: friendlyModelName }, 'blue'); isApiWorking = false; try { const testPrompt = "Respond with only the single word 'test'."; const result = await fetchFromApi(testPrompt); if (result && result.toLowerCase().includes('test')) { updateApiStatusDisplay('apiStatusSuccess', { model: friendlyModelName }, 'green'); isApiWorking = true; sessionStorage.setItem('hangmanApiKey', apiKey); localStorage.setItem('hangmanApiModel', apiModel); if (isTranslationEnabled && currentLanguage !== 'en' && !translationsCache[currentLanguage]) { applyTranslation(); } else { updateTranslationStatus(); } } else { throw new Error(`API test failed. Unexpected response: ${result || '(empty response)'}`); } } catch (error) { console.error('API test error:', error); const errorMsg = error.message || 'Unknown error'; updateApiStatusDisplay('apiStatusFailed', { error: errorMsg }, 'red'); isApiWorking = false; sessionStorage.removeItem('hangmanApiKey'); if (isTranslationEnabled && currentLanguage !== 'en') updateTranslationStatus(); } }
            function updateApiStatusDisplay(messageKeyOrText = null, params = {}, color = '#555') { /* ... (same) ... */ const statusEl = document.getElementById('api-status'); if (!statusEl) return; const friendlyModelName = getFriendlyApiModelName(apiModel); let statusText = ''; const sessionApiKey = sessionStorage.getItem('hangmanApiKey'); if (!sessionApiKey || sessionApiKey !== apiKey) { if (isApiWorking && apiKey) { console.log("API Status Check: Key mismatch or empty, marking API as not working."); } isApiWorking = false; } if (messageKeyOrText && ORIGINAL_STRINGS[messageKeyOrText]) { let baseText = getTranslation(messageKeyOrText); if (['apiStatusTesting', 'apiStatusSuccess', 'apiStatusUsingAI', 'apiStatusUsingDetailsOnly', 'apiStatusNotVerified'].includes(messageKeyOrText)) { params.model = friendlyModelName; } Object.keys(params).forEach(key => { const regex = new RegExp(`\\{${key}\\}`, 'g'); baseText = baseText.replace(regex, params[key]); }); statusText = baseText; statusEl.style.color = color; statusEl.textContent = statusText; } else if (messageKeyOrText) { statusText = messageKeyOrText; statusEl.style.color = color; statusEl.textContent = statusText; } else { const keyEntered = !!apiKey; if (!keyEntered) { updateApiStatusDisplay('apiStatusInitial', {}, '#555'); isApiWorking = false; } else if (isApiWorking) { const statusKey = useApiForWords ? 'apiStatusUsingAI' : 'apiStatusUsingDetailsOnly'; updateApiStatusDisplay(statusKey, { model: friendlyModelName }, 'green'); } else { updateApiStatusDisplay('apiStatusNotVerified', { model: friendlyModelName }, 'orange'); } } }
            async function fetchFromApi(prompt, maxTokens = 100) { /* ... (same) ... */ if (!apiKey) throw new Error("API key is missing"); let apiEndpoint = '', requestData = {}, headers = { 'Content-Type': 'application/json' }; const friendlyModelName = getFriendlyApiModelName(apiModel); console.log(`[fetchFromApi] Sending request to ${friendlyModelName} (Max Tokens: ${maxTokens})`); try { const needsJson = prompt.includes("Respond ONLY with a valid JSON object"); if (apiModel === 'gemini-1.5-flash') { apiEndpoint = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`; requestData = { contents: [{ parts: [{ text: prompt }] }], generationConfig: { maxOutputTokens: maxTokens, temperature: 0.5, topP: 0.9, responseMimeType: needsJson ? "application/json" : "text/plain" } }; } else if (apiModel === 'openai') { apiEndpoint = 'https://api.openai.com/v1/chat/completions'; headers['Authorization'] = `Bearer ${apiKey}`; requestData = { model: 'gpt-3.5-turbo', messages: [{ role: 'user', content: prompt }], max_tokens: maxTokens, temperature: 0.5 }; if (needsJson) { requestData.response_format = { type: "json_object" }; } } else if (apiModel === 'anthropic') { apiEndpoint = 'https://api.anthropic.com/v1/messages'; headers['anthropic-version'] = '2023-06-01'; headers['x-api-key'] = apiKey; requestData = { model: 'claude-3-haiku-20240307', max_tokens: maxTokens, messages: [{ role: 'user', content: prompt }], temperature: 0.5 }; } else { throw new Error(`Unsupported API model: ${apiModel}`); } const response = await fetch(apiEndpoint, { method: 'POST', headers: headers, body: JSON.stringify(requestData), signal: AbortSignal.timeout(35000) }); if (!response.ok) { let errorBody = `Status: ${response.status}`; try { const errorJson = await response.json(); errorBody = JSON.stringify(errorJson.error || errorJson); } catch (e) { try { errorBody = await response.text(); } catch (e2) {} } throw new Error(`API request failed. ${errorBody.substring(0, 200)}`); } const data = await response.json(); let responseText = ''; if (apiModel === 'gemini-1.5-flash') { responseText = data.candidates?.[0]?.content?.parts?.[0]?.text || ''; } else if (apiModel === 'openai') { responseText = data.choices?.[0]?.message?.content || ''; } else if (apiModel === 'anthropic') { responseText = data.content?.find(block => block.type === 'text')?.text || ''; } return responseText.trim(); } catch (error) { console.error(`[fetchFromApi] API error for ${friendlyModelName}:`, error); if (error.name === 'TimeoutError') { throw new Error("API request timed out."); } if (error.message && (error.message.includes('401') || error.message.toLowerCase().includes('invalid api key') || error.message.toLowerCase().includes('authentication error'))) { isApiWorking = false; sessionStorage.removeItem('hangmanApiKey'); updateApiStatusDisplay('apiStatusFailed', { error: 'Authentication failed. Check key.' }, 'red'); if (isTranslationEnabled && currentLanguage !== 'en') updateTranslationStatus(); } throw error; } }
            async function getWordFromApi() { /* ... (same) ... */ const wordType = currentDifficulty === "easy" ? "simple common" : currentDifficulty === "medium" ? "moderately common" : "less common but recognizable"; const lengthRange = currentDifficulty === "easy" ? "4-7" : currentDifficulty === "medium" ? "6-10" : "10-16"; const uniqueifier = Date.now(); const randomSeed = Math.floor(Math.random() * 10000); const excludeList = previousApiWords.length > 0 ? `\nDO NOT use any of these words (case-insensitive): ${previousApiWords.join(', ')}.` : ''; const prompt = `Generate a **random**, single English word suitable for a hangman game. Request ID: ${uniqueifier}-${randomSeed}\n\nWord characteristics:\n- Difficulty: ${currentDifficulty} (${wordType})\n- Length: Approximately ${lengthRange} letters\n- Must be a real dictionary word\n- Must contain ONLY standard English letters (A-Z)\n- Must be safe for all ages${excludeList}\n\nIMPORTANT: Respond with ONLY the single word itself, nothing else (no explanations, quotes, punctuation, or introduction).`; console.log(`[getWordFromApi] Difficulty: ${currentDifficulty}, Random seed: ${randomSeed}, Attempting to exclude: ${previousApiWords.join(', ')}`); let attempts = 0; const maxAttempts = 3; while (attempts < maxAttempts) { attempts++; try { const response = await fetchFromApi(prompt, 25); if (!response) { console.warn(`[getWordFromApi] API returned empty response on attempt ${attempts}`); if (attempts < maxAttempts) await new Promise(resolve => setTimeout(resolve, 300)); continue; } let potentialWord = response.match(/^[a-zA-Z]+$/)?.[0] || response.split(/[\s\n,.:;"']/)[0].replace(/[^a-zA-Z]/g, ''); const cleanedWord = potentialWord.toUpperCase(); const minLen = currentDifficulty === "easy" ? 3 : currentDifficulty === "medium" ? 5 : 8; const maxLen = currentDifficulty === "easy" ? 9 : currentDifficulty === "medium" ? 14 : 20; const isValid = cleanedWord.length >= minLen && cleanedWord.length <= maxLen && /^[A-Z]+$/.test(cleanedWord); if (isValid && !previousApiWords.includes(cleanedWord)) { previousApiWords.push(cleanedWord); if (previousApiWords.length > MAX_STORED_WORDS) { previousApiWords.shift(); } console.log(`[getWordFromApi] Valid, non-duplicate word found: "${cleanedWord}" (attempt ${attempts})`); return cleanedWord; } else { if (!isValid) console.warn(`[getWordFromApi] Word "${cleanedWord}" (from raw: "${response}") failed validation (len: ${cleanedWord.length}, allowed: ${minLen}-${maxLen}) - trying again (attempt ${attempts}/${maxAttempts})`); if (previousApiWords.includes(cleanedWord)) console.warn(`[getWordFromApi] Duplicate word "${cleanedWord}" received - trying again (attempt ${attempts}/${maxAttempts})`); if (attempts < maxAttempts) await new Promise(resolve => setTimeout(resolve, 300)); } } catch (error) { console.error(`[getWordFromApi] Error during attempt ${attempts}:`, error.message); if (attempts >= maxAttempts) { console.error("[getWordFromApi] API fetch error occurred on final attempt."); break; } await new Promise(resolve => setTimeout(resolve, 500)); } } console.error("[getWordFromApi] Failed to get a valid, unique word after", maxAttempts, "attempts. Falling back."); return null; }
            async function fetchBilingualWordDetails(word, targetLangCode) { /* ... (same) ... */ if (!isApiWorking || !apiKey || !word) return null; const targetLangName = SUPPORTED_LANGUAGES[targetLangCode] || targetLangCode; let prompt; const desiredJsonStructure = `{
  "english": {
    "definition": "Concise English definition of the word.",
    "examples": [
      "First distinct English example sentence using the word.",
      "Second distinct English example sentence, ideally showing a different usage if applicable."
    ]
  },
  "translation": {
    "targetLanguage": "${targetLangName}",
    "wordTranslation": "The translation of the word '${word}' into ${targetLangName}.",
    "wordTranscription": "A simple phonetic transcription of the English word '${word}' using ${targetLangName} script/phonetics (e.g., using Cyrillic for Bulgarian like 'трейн' for 'train', or IPA if simpler). If transcription is complex or ambiguous, provide the most common one, or null if not feasible.",
    "definition": "Concise ${targetLangName} translation of the English definition.",
    "examples": [
      "${targetLangName} translation of the first English example sentence.",
      "${targetLangName} translation of the second English example sentence."
    ]
  }
}`; if (targetLangCode === 'en') { prompt = `Provide details for the English word "${word}". Respond ONLY with a valid JSON object with the following structure:\n{\n  "english": {\n    "definition": "Concise English definition.",\n    "examples": ["English example 1.", "English example 2."]\n  }\n}`; } else { prompt = `Provide details for the English word "${word}" and its translation into ${targetLangName} (${targetLangCode}). Respond ONLY with a valid JSON object following this exact structure, filling in the requested information:\n${desiredJsonStructure}\n\nIMPORTANT: Ensure the response is solely the JSON object, without any introduction, explanation, or markdown formatting. Provide concise definitions and two distinct examples in both languages. For wordTranscription, use ${targetLangName} script/phonetics or simple IPA.`; } try { const rawResponse = await fetchFromApi(prompt, 2500); console.log("Raw bilingual details response:", rawResponse); let parsedDetails = null; try { const cleanedResponse = rawResponse.replace(/^```json\s*|\s*```$/g, ''); parsedDetails = JSON.parse(cleanedResponse); } catch (parseError) { console.error("Failed to parse details JSON:", parseError, "Raw:", rawResponse); if (rawResponse.length < 200 && !rawResponse.includes('{')) { return { english: { definition: rawResponse, examples: [] }, translation: null }; } throw new Error("API response was not valid JSON."); } if (parsedDetails && parsedDetails.english && parsedDetails.english.definition) { if (targetLangCode !== 'en' && !parsedDetails.translation) { console.warn(`Translation object missing in response for ${targetLangCode}.`); parsedDetails.translation = null; } if (parsedDetails.translation && parsedDetails.translation.wordTranscription === "") { parsedDetails.translation.wordTranscription = null; } return parsedDetails; } else { console.error("Parsed JSON is missing required 'english' structure:", parsedDetails); throw new Error("Received JSON is missing expected structure."); } } catch (error) { console.error("Error fetching bilingual word details:", error); return { error: error.message || "Failed to fetch details." }; } }

            // --- UI Translation Functions ---
            function getTranslation(key, fallback = null, params = {}) { /* ... (same) ... */ const lang = isTranslationEnabled ? currentLanguage : 'en'; let text = translationsCache[lang]?.[key] ?? translationsCache['en']?.[key] ?? fallback ?? key; Object.keys(params).forEach(paramKey => { const regex = new RegExp(`\\{${paramKey}\\}`, 'g'); text = text.replace(regex, params[paramKey]); }); return text; }
            function updateToggleButtonState() { /* ... (same) ... */ const translateToggleBtn = document.getElementById('translate-toggle-btn'); if (translateToggleBtn) { translateToggleBtn.textContent = isTranslationEnabled ? getTranslation('showOriginal') : getTranslation('translateUI'); } }
            function updateTranslationStatus(messageKey = null, params = {}, color = '#666') { /* ... (same) ... */ const statusEl = document.getElementById('translation-status'); if (!statusEl) return; if (messageKey) { statusEl.textContent = getTranslation(messageKey, messageKey, params); statusEl.style.color = color; } else { if (isTranslationEnabled && currentLanguage !== 'en') { if (isFetchingTranslation) { updateTranslationStatus('translationStatusLoading', {}, 'blue'); } else if (translationsCache[currentLanguage]) { updateTranslationStatus('translationStatusSuccess', { language: SUPPORTED_LANGUAGES[currentLanguage] }, 'green'); } else if (!isApiWorking || !apiKey) { updateTranslationStatus('translationStatusNoAPI', {}, 'orange'); } else { updateTranslationStatus('translationStatusError', {}, 'red'); } } else { statusEl.textContent = ''; } } }
            function toggleTranslation() { /* ... (same) ... */ isTranslationEnabled = !isTranslationEnabled; console.log("Translation toggled:", isTranslationEnabled); saveToSessionStorage('hangmanTranslationEnabled', isTranslationEnabled); updateToggleButtonState(); if (isTranslationEnabled) { applyTranslation(); } else { revertToOriginal(); } updateTranslationStatus(); renderGameState(); }
            function changeLanguage(langCode) { /* ... (same) ... */ if (!SUPPORTED_LANGUAGES[langCode] || langCode === currentLanguage) { return; } currentLanguage = langCode; console.log("Language changed to:", currentLanguage); saveToSessionStorage('hangmanCurrentLanguage', currentLanguage); if (isTranslationEnabled) { applyTranslation(); } else { updateToggleButtonState(); updateTranslationStatus(); renderGameState(); } }
            function applyTranslation() { /* ... (same) ... */ console.log(`Applying translation for: ${currentLanguage}`); if (!isTranslationEnabled || currentLanguage === 'en') { revertToOriginal(); updateTranslationStatus(); return; } if (translationsCache[currentLanguage]) { console.log("Using cached translations for", currentLanguage); updateUIWithTranslations(currentLanguage); updateTranslationStatus(); } else if (isApiWorking && apiKey) { console.log("Fetching translations for", currentLanguage); fetchAndCacheTranslations(currentLanguage); } else { console.warn("Cannot fetch translation: API not working/key missing."); revertToOriginal(); updateTranslationStatus('translationStatusNoAPI', {}, 'orange'); } renderGameState(); }
             async function fetchAndCacheTranslations(langCode) { /* ... (same) ... */ if (isFetchingTranslation) { console.log("Translation fetch already in progress for", langCode); return; } if (!isApiWorking || !apiKey) { console.error("Cannot fetch: API not ready."); revertToOriginal(); updateTranslationStatus('translationStatusNoAPI', {}, 'orange'); return; } isFetchingTranslation = true; updateTranslationStatus('translationStatusLoading', {}, 'blue'); const languageName = SUPPORTED_LANGUAGES[langCode] || langCode; const stringsToTranslate = JSON.stringify(ORIGINAL_STRINGS, null, 2); const prompt = `Translate the following English UI text elements into ${languageName} (${langCode}). Respond ONLY with a valid JSON object where keys match the provided English keys and values are the ${languageName} translations. Do not include explanations or markdown formatting. Ensure the JSON is complete and valid.\n\n${stringsToTranslate}`; try { const rawResponse = await fetchFromApi(prompt, 2500); console.log("Raw translation response:", rawResponse); let parsedTranslations = null; try { const cleanedResponse = rawResponse.replace(/^```json\s*|\s*```$/g, ''); parsedTranslations = JSON.parse(cleanedResponse); } catch (parseError) { console.error("Failed to parse translation JSON:", parseError, "Raw:", rawResponse); throw new Error("API response was not valid JSON."); } if (parsedTranslations && typeof parsedTranslations === 'object') { if (parsedTranslations.gameTitle && parsedTranslations.newGame) { translationsCache[langCode] = parsedTranslations; saveToSessionStorage('hangmanTranslationsCache', translationsCache); console.log(`Translations for ${langCode} fetched and cached.`); updateUIWithTranslations(langCode); updateTranslationStatus(); } else { console.error("Parsed JSON seems incomplete or invalid:", parsedTranslations); throw new Error("Received JSON is missing expected keys."); } } else { throw new Error("Parsed response is not a valid object."); } } catch (error) { console.error(`Error fetching translations for ${langCode}:`, error); revertToOriginal(); updateTranslationStatus('translationStatusError', {}, 'red'); } finally { isFetchingTranslation = false; renderGameState(); } }
             function applyStaticTranslations() { /* ... (same) ... */ const lang = isTranslationEnabled ? currentLanguage : 'en'; if (translationsCache[lang]) { updateUIWithTranslations(lang); } else { updateUIWithTranslations('en'); } }
             function updateUIWithTranslations(langCode) { /* ... (same) ... */ console.log("Updating UI with translations for:", langCode); const translations = translationsCache[langCode]; if (!translations) { console.error("No translations available for", langCode); revertToOriginal(); return; } document.querySelectorAll('[data-translate-key]').forEach(element => { const key = element.getAttribute('data-translate-key'); const translatedText = translations[key]; if (translatedText !== undefined) { if (element.tagName === 'INPUT' && element.placeholder !== undefined) { element.placeholder = translatedText; } else if (element.tagName === 'OPTION') { element.textContent = translatedText; } else if (element.tagName === 'TITLE') { document.title = translatedText; } else { element.textContent = translatedText; } } else if (langCode !== 'en') { const fallbackText = translationsCache['en']?.[key]; if (fallbackText !== undefined) { if (element.tagName === 'INPUT' && element.placeholder !== undefined) element.placeholder = fallbackText; else if (element.tagName === 'OPTION') element.textContent = fallbackText; else if (element.tagName === 'TITLE') document.title = fallbackText; else element.textContent = fallbackText; console.warn(`Missing translation for key '${key}' in ${langCode}. Used English fallback.`); } else { console.warn(`Missing translation and English fallback for key '${key}'.`); } } }); updateStatusMessage(statusMessage); updateToggleButtonState(); }
            function revertToOriginal() { /* ... (same) ... */ console.log("Reverting UI to original English"); updateUIWithTranslations('en'); updateTranslationStatus(); }

            // --- Event Handlers & Loop ---
            function onCanvasContainerResize() { /* ... (same) ... */ if (!camera || !renderer) return; const newWidth = window.innerWidth; const newHeight = window.innerHeight; if (newWidth > 0 && newHeight > 0) { camera.aspect = newWidth / newHeight; camera.updateProjectionMatrix(); renderer.setSize(newWidth, newHeight); console.log(`Hangman Iframe: Resized to ${newWidth}x${newHeight}`); } else { console.warn("Hangman Iframe: Window resize triggered with zero dimensions."); } }
            // MODIFIED: setupKeyboardControls checks isMobile
            function setupKeyboardControls() {
                 document.addEventListener('keydown', (event) => {
                     const activeElement = document.activeElement;
                     const isInGameUI = gameContainerElement && gameContainerElement.contains(activeElement);
                     const isInputFocused = activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.tagName === 'SELECT');

                     if (gameOver || event.ctrlKey || event.metaKey || event.altKey || !currentWord || currentWord==="ERROR") return;
                     if (isInGameUI && isInputFocused) { return; } // Always allow typing in inputs

                     if (event.key.length === 1 && event.key.match(/[a-z]/i)) {
                         // Block physical keyboard for guesses on mobile
                         if (isMobile) {
                             console.log("Mobile detected: Physical keyboard guess ignored.");
                             event.preventDefault(); // Prevent default (like scrolling) if applicable
                             return;
                         }
                         // Desktop: Process guess
                         const letter = event.key.toUpperCase();
                         const button = document.querySelector(`#letters-container .letter-button[data-letter="${letter}"]`);
                         if (button && !button.disabled) { handleGuess(letter); }
                     }
                 });
             }
            function animate() { /* ... (same) ... */ animationFrameId = requestAnimationFrame(animate); const deltaTime = 1 / 60; let frameRendered = false; try { if (gameOver && world && hangmanPhysicsBodies.length > 0 && hangmanPhysicsBodies[0]?.body?.world) { world.step(deltaTime); hangmanPhysicsBodies.forEach(item => { if (item?.body && item?.mesh) { item.mesh.position.copy(item.body.position); item.mesh.quaternion.copy(item.body.quaternion); } }); } } catch (physicsError) { console.error("Hangman Iframe: Physics step/sync error:", physicsError); } try { if (controls) controls.update(); if (renderer && scene && camera) { renderer.render(scene, camera); frameRendered = true; } else { if (!renderer) console.warn("Hangman Iframe: Animate - Renderer missing!"); if (!scene) console.warn("Hangman Iframe: Animate - Scene missing!"); if (!camera) console.warn("Hangman Iframe: Animate - Camera missing!"); } } catch (renderError) { console.error("Hangman Iframe: Render error in animate loop:", renderError); } }

            // --- Start Initializing ---
            init();

        } // End of initHangmanGame
    </script>
</body>
</html>
