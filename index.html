<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-translate-key="pageTitle">3D Hangman Game</title>
    <!-- Libraries loaded via CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <style>
        /* Basic reset */
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: Arial, sans-serif; }
        canvas { display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }

        /* Game UI Container */
        #game-container { position: absolute; top: 15px; left: 15px; background: rgba(255,255,255,0.9); padding: 15px; border-radius: 8px; z-index: 100; color: #333; box-shadow: 0 6px 12px rgba(0,0,0,0.25); max-width: 400px; width: 90%; user-select: none; font-size: 14px; box-sizing: border-box; }
        #game-container * { box-sizing: border-box; }
        #game-container > *:not(#game-container-header):not(#translation-controls) { user-select: auto; }
        #game-container-header { cursor: move; background-color: #e8e8e8; padding: 8px 15px; margin: -15px -15px 15px -15px; border-top-left-radius: 8px; border-top-right-radius: 8px; font-size: 16px; font-weight: bold; text-align: center; }

        /* Game Elements */
        #word-display { font-size: 24px; letter-spacing: 5px; margin-bottom: 15px; font-family: 'Courier New', monospace; text-align: center; min-height: 35px; word-break: break-all; line-height: 1.3; }
        #status-container { display: flex; justify-content: center; align-items: center; margin: 15px 0 10px 0; min-height: 24px; flex-wrap: wrap; }
        #status { font-weight: bold; text-align: center; color: #444; font-size: 15px; flex-grow: 1; padding-right: 5px; }
        #word-source { font-size: 12px; font-style: italic; color: #666; text-align: center; flex-shrink: 0; width: 100%; margin-top: 2px; }
        #used-letters-container { margin: 10px 0; font-family: 'Courier New', monospace; text-align: center; font-size: 14px; min-height: 20px; }
        #used-letters { font-weight: bold; color: #555; }
        #letters-container { margin: 15px 0; display: flex; flex-wrap: wrap; justify-content: center; gap: 5px; }
        .letter-button { padding: 8px 10px; margin: 0; cursor: pointer; border-radius: 4px; border: 1px solid #ccc; background: #fff; font-weight: bold; transition: all 0.15s ease-in-out; min-width: 35px; text-align: center; font-size: 14px; }
        .letter-button:hover:not(.disabled) { background: #e8f4ff; transform: translateY(-2px); box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .letter-button.disabled { background: #e0e0e0; cursor: not-allowed; opacity: 0.6; transform: none; box-shadow: none; }
        .letter-button.correct { background: #b7e8b7; border-color: #8fbc8f; color: #1a5a1a; }
        .letter-button.incorrect { background: #f8c6c6; border-color: #d8a0a0; color: #8b0000; }

        /* Word Details Placeholder */
        #word-details { display: none; }

        /* Game Controls */
        #game-controls { display: flex; justify-content: space-between; align-items: center; margin-top: 15px; gap: 10px; flex-wrap: wrap; }
        #new-game-btn { padding: 10px 15px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; transition: background 0.3s; flex-shrink: 0; font-size: 14px; }
        #new-game-btn:hover { background: #3e8e41; }
        #difficulty-select { padding: 9px; border-radius: 4px; border: 1px solid #ccc; flex-grow: 1; min-width: 150px; font-size: 14px; }

        /* Translation Controls */
        #translation-controls { margin-top: 15px; padding-top: 15px; border-top: 1px solid #ccc; display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
        #translation-controls label { font-size: 14px; font-weight: bold; margin-right: 5px; }
        #language-select { padding: 7px; border-radius: 4px; border: 1px solid #ccc; font-size: 13px; flex-grow: 1; min-width: 120px; }
        #translate-toggle-btn { padding: 7px 12px; font-size: 13px; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 4px; transition: background-color 0.3s; }
        #translate-toggle-btn:hover { background-color: #0056b3; }
        #translation-status { font-size: 12px; width: 100%; min-height: 16px; font-style: italic; color: #666; margin-top: 5px; }

        /* API Settings */
        #api-settings { margin-top: 20px; padding-top: 15px; border-top: 1px solid #ccc; }
        #api-settings h4 { text-align: center; margin-bottom: 8px; font-size: 1.1em; }
        .api-input-container { display: flex; flex-wrap: wrap; gap: 8px; margin: 10px 0; align-items: center; }
        #api-key-input { flex-grow: 1; padding: 8px; border: 1px solid #ccc; border-radius: 4px; min-width: 150px; font-size: 13px;}
        #api-model-select { padding: 8px; border-radius: 4px; border: 1px solid #ccc; font-size: 13px;}
        #api-status { font-size: 13px; margin-top: 5px; min-height: 20px; font-style: italic; }
        #api-controls { display: flex; gap: 10px; align-items: center; width: 100%; flex-wrap: wrap; }
        #api-controls label { display: flex; align-items: center; font-size: 14px; }
        #use-api-checkbox { margin-right: 5px; transform: scale(1.1); }
        #test-api-btn { padding: 7px 12px; font-size: 13px; cursor: pointer; margin-left: auto; }
        #api-key-warning { font-size: 12px; color: #888; margin-top: 5px; }

        /* Details Popup Styles */
        #details-popup-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.6); z-index: 1000; display: none; justify-content: center; align-items: center; }
        #details-popup { background: #fff; padding: 25px; border-radius: 8px; box-shadow: 0 8px 20px rgba(0,0,0,0.3); max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto; z-index: 1001; }
        #details-popup h4 { margin-top: 0; margin-bottom: 15px; font-size: 1.3em; color: #333; text-align: center; border-bottom: 1px solid #eee; padding-bottom: 10px; }
         #details-popup h5 { margin: 15px 0 5px 0; font-size: 1.1em; color: #555; font-style: italic; }
        #details-popup p { margin: 5px 0 10px 0; line-height: 1.5; font-size: 0.95em; }
        #details-popup strong { font-weight: bold; color: #111; }
         /* MODIFIED: Styles for translation and transcription */
         #details-popup .word-translation-block {
             text-align: center;
             margin-bottom: 15px;
         }
         #details-popup .word-translation {
             font-weight: bold;
             font-size: 1.2em;
             color: #0056b3; /* Blue */
             display: inline-block; /* Keep label and value together */
             margin-right: 15px;
         }
          #details-popup .word-transcription {
             font-style: italic;
             font-size: 1.1em;
             color: #444;
             display: inline-block;
         }
         #details-popup .section-separator { border-top: 1px dashed #ccc; margin: 15px 0; }
        #details-popup .error { color: #a00; font-style: italic; }
        #details-popup-controls { text-align: center; margin-top: 20px; }
        #details-popup-ok-btn { padding: 10px 25px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 1em; transition: background 0.3s; }
        #details-popup-ok-btn:hover { background: #0056b3; }


        /* Responsive Adjustments */
        @media (max-width: 600px) { /* ... (styles remain the same) ... */ #game-container { left: 10px; top: 10px; max-width: calc(100% - 20px); width: calc(100% - 20px); padding: 10px; font-size: 13px; } #game-container-header { cursor: default; margin: -10px -10px 10px -10px; font-size: 15px; } #word-display { font-size: 18px; letter-spacing: 3px; min-height: 30px;} .letter-button { padding: 7px 8px; min-width: 30px; font-size: 13px;} #game-controls { flex-direction: column; align-items: stretch; } #difficulty-select { width: 100%; margin-top: 8px; font-size: 13px; } #new-game-btn { font-size: 14px; } #status { font-size: 14px; } #translation-controls { flex-direction: column; align-items: stretch; } #language-select { width: 100%; margin-top: 5px; } #translate-toggle-btn { width: 100%; margin-top: 8px; } .api-input-container { flex-direction: column; align-items: stretch; } #api-controls { justify-content: space-between; } #test-api-btn { margin-left: 0; margin-top: 5px; } #api-model-select { width: 100%; margin-top: 5px;} #api-key-input { width: 100%; } #details-popup { width: 95%; padding: 15px; } #details-popup h4 { font-size: 1.1em; } #details-popup p { font-size: 0.9em; } }
        @media (max-width: 420px) { /* ... (styles remain the same) ... */ .letter-button { min-width: 26px; padding: 6px; font-size: 12px; gap: 3px;} #word-display { font-size: 16px; letter-spacing: 2px;} #game-container { left: 5px; top: 5px; width: calc(100% - 10px); } }
    </style>
</head>
<body>
    <!-- Canvas -->
    <!-- Game UI -->
    <div id="game-container">
        <h3 id="game-container-header"><span data-translate-key="gameTitle">3D Hangman Game</span></h3>
        <div id="word-display"></div>
        <div id="status-container">
            <span id="status" data-translate-key="statusLoading">Loading Game...</span>
            <span id="word-source"></span>
        </div>
        <div id="used-letters-container">
            <span data-translate-key="usedLettersLabel">Used letters</span>: <span id="used-letters"></span>
        </div>
        <div id="word-details"> <!-- Hidden --> </div>
        <div id="letters-container"></div>
        <div id="game-controls">
            <button id="new-game-btn" data-translate-key="newGame">New Game</button>
            <select id="difficulty-select">
                <option value="easy" data-translate-key="easyDifficulty">Easy (6 guesses)</option>
                <option value="medium" selected data-translate-key="mediumDifficulty">Medium (8 guesses)</option>
                <option value="hard" data-translate-key="hardDifficulty">Hard (10 guesses)</option>
            </select>
        </div>
        <!-- Translation Controls -->
        <div id="translation-controls">
            <label for="language-select" data-translate-key="languageLabel">Language:</label>
            <select id="language-select"> </select>
            <button id="translate-toggle-btn" data-translate-key="translateUI">Translate UI</button>
            <div id="translation-status"></div>
        </div>
        <!-- API Settings -->
        <div id="api-settings">
             <h4 data-translate-key="aiSettingsTitle">AI Word Generation & Details (Optional)</h4>
             <div id="api-key-warning" data-translate-key="apiKeyWarning">Note: API key is stored only for this browser session.</div>
             <div class="api-input-container">
                 <input type="password" id="api-key-input" placeholder="Enter AI API Key" data-translate-key="apiKeyPlaceholder" />
                 <select id="api-model-select">
                     <option value="gemini-1.5-flash">Google Gemini Flash</option>
                     <option value="openai">OpenAI GPT-3.5</option>
                     <option value="anthropic">Anthropic Claude Haiku</option>
                 </select>
             </div>
             <div id="api-controls">
                 <label><input type="checkbox" id="use-api-checkbox" /> <span data-translate-key="useAILabel">Use AI</span></label>
                 <button id="test-api-btn" data-translate-key="testApiButton">Test/Save Key</button>
             </div>
             <div id="api-status" data-translate-key="apiStatusInitial">Enter key and click Test/Save.</div>
         </div>
    </div>

    <!-- Details Popup HTML -->
    <div id="details-popup-overlay">
        <div id="details-popup">
            <h4 id="details-popup-title" data-translate-key="detailsTitle">Word Details</h4>
            <div id="details-popup-content"> <!-- Content injected here --> </div>
            <div id="details-popup-controls">
                <button id="details-popup-ok-btn" data-translate-key="okButton">OK</button>
            </div>
        </div>
    </div>


    <script>
        // Wrapper to wait for Libraries
        function waitForLibraries(callback) { /* ... (same) ... */ const maxAttempts = 20; let attempts = 0; function check() { attempts++; console.log(`[Lib Waiter] Attempt ${attempts} to check libraries...`); if (typeof THREE !== 'undefined' && typeof CANNON !== 'undefined' && typeof THREE.OrbitControls !== 'undefined') { console.log("[Lib Waiter] Libraries loaded! Proceeding."); callback(); } else if (attempts >= maxAttempts) { console.error("[Lib Waiter] Libraries did not load after multiple attempts."); const statusEl = document.getElementById('status'); if (statusEl) statusEl.textContent = "Error: Required JavaScript libraries failed to load."; if (typeof THREE === 'undefined') console.error("[Lib Waiter] THREE is missing."); if (typeof CANNON === 'undefined') console.error("[Lib Waiter] CANNON is missing."); if (typeof THREE.OrbitControls === 'undefined') console.error("[Lib Waiter] THREE.OrbitControls is missing."); } else { setTimeout(check, 500); } } check(); }
        window.addEventListener('load', () => waitForLibraries(initHangmanGame));

        // =============================================
        // HANGMAN GAME CODE
        // =============================================
        function initHangmanGame() {
            console.log("Hangman: initHangmanGame() called.");

            // --- Config & State ---
            const HANGMAN_PART_COUNT = { easy: 6, medium: 8, hard: 10 };
            const DEFAULT_WORDS = { /* ... (same word lists) ... */ easy: ["SKY","PIE","CAT","DOG","SUN","RUN","BALL","TREE","BOOK","CUP","FISH","SHIP","FROG","DUCK","MILK","STAR","HAT","KEY","LAMP","NOTE","APPLE"], medium: ["COMPUTER","KEYBOARD","MONITOR","ELEPHANT","GIRAFFE","STRAWBERRY","PINEAPPLE","WATERMELON","CHOCOLATE","MOUNTAIN","UNIVERSE","TREASURE","JOURNEY","ADVENTURE","KNOWLEDGE","BIRTHDAY","FESTIVAL","VACATION","PAINTING","EXERCISE","BEACH","BRAIN","CHAIR","DANCE","EARTH","FLUTE","GHOST","HOTEL","JUICE","LEMON","MOUSE","NORTH","OCEAN","PANDA","QUEEN","ROBOT","SNAKE","TIGER","UMBRELLA","VOICE","WATCH","XYLOPHONE","YACHT","ZEBRA"], hard: ["ENCYCLOPEDIA","PHOTOSYNTHESIS","EXTRAORDINARY","PERPENDICULAR","REVOLUTIONARY","SOPHISTICATED","PHILOSOPHICAL","CONSTELLATION","BIODIVERSITY","QUINTESSENTIAL","ENTREPRENEURSHIP","EXTRATERRESTRIAL","MULTIDISCIPLINARY","PALEONTOLOGIST","THERMODYNAMICS","CRYPTOCURRENCY","INFRASTRUCTURE","PARLIAMENTARY","BIOTECHNOLOGY","ANTHROPOLOGIST","ADVENTURE","BICYCLE","CHAMPION","DINOSAUR","FIREWORKS","HELICOPTER","INTERNET","JELLYFISH","KANGAROO","LIGHTHOUSE","MAGNIFY","NEIGHBOR","ORCHESTRA","PENGUIN","QUICKSAND","RAINBOW","SPACESHIP","TELESCOPE","UNICORN","VOLCANO","WATERFALL","YESTERDAY","ZODIAC"] };
            const FACE_CHANGE_GUESS_OFFSET = 1;
            let scene, camera, renderer, controls, world;
            let currentWord = "", guessedLetters = [], wrongGuesses = 0, maxWrongGuesses = 8;
            let gameOver = false, animationFrameId;
            let currentDifficulty = "medium", isMobile = false;
            let statusMessage = "Loading...", wordSource = "";
            let gameContainerElement, detailsPopupOverlay, detailsPopupContent, detailsPopupTitle;

            // API State
            let apiKey = sessionStorage.getItem('hangmanApiKey') || '';
            let apiModel = localStorage.getItem('hangmanApiModel') || 'gemini-1.5-flash';
            let useApiForWords = localStorage.getItem('hangmanUseApi') === 'true';
            let isApiWorking = false;

            // Word History & 3D/Physics
            let previousApiWords = [], MAX_STORED_WORDS = 20;
            let hangmanParts = [], hangmanPhysicsBodies = [];
            let gallows = {}, gallowsBodies = [];
            let groundBody, smileFaceGroup = null, grumpyFaceGroup = null, headMainSphere = null;
            const woodMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8, metalness: 0.2 });
            const ropeMaterial = new THREE.MeshStandardMaterial({ color: 0xBDA580, roughness: 0.9, metalness: 0.1 });
            const skinMaterial = new THREE.MeshStandardMaterial({ color: 0xFFDAB9, roughness: 0.6, metalness: 0.1 });
            const blueMaterial = new THREE.MeshStandardMaterial({ color: 0x4682B4, roughness: 0.7, metalness: 0.1 });
            const blackMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.7, metalness: 0.1 });
            const faceDetailMaterial = new THREE.MeshBasicMaterial({ color: 0x222222, side: THREE.DoubleSide });

            // --- Translation State & Config ---
            const SUPPORTED_LANGUAGES = { 'en': 'English', 'bg': 'Български', 'de': 'Deutsch', 'es': 'Español', 'fr': 'Français' };
            // MODIFIED: Added wordTranscriptionLabel
            const ORIGINAL_STRINGS = {
                pageTitle: "3D Hangman Game", gameTitle: "3D Hangman Game",
                statusLoading: "Loading Game...", statusStartingGame: "Starting new game...", statusChoosingWord: "Choosing word...",
                statusGuess: "Guess a letter! {guessesLeft} guesses left.", statusCorrect: "Correct! '{letter}' is in the word.",
                statusWrong: "Wrong! '{letter}' not found. {guessesLeft} guesses left.",
                statusWin: "Congratulations! You guessed \"{word}\"!", statusLoss: "Game Over! The word was \"{word}\".",
                sourcePrefix: "Source:", usedLettersLabel: "Used letters",
                detailsTitle: "Details for \"{word}\"", detailsApiNeeded: "API not configured or working - cannot fetch details",
                detailsInvalidWord: "Invalid word - cannot fetch details", detailsFetching: "Fetching details...",
                detailsFetchFailed: "Could not fetch details for \"{word}\".", detailsFetchError: "Error fetching details for \"{word}\".",
                detailsOneExampleOnly: "Only one example sentence found.",
                wordTranslationLabel: "Translation ({language})", wordTranscriptionLabel: "Transcription", // NEW
                englishContentLabel: "English", translatedContentLabel: "{language}",
                definitionLabel: "Definition", examplesLabel: "Examples",
                translationError: "Translation not available", notAvailable: "N/A", okButton: "OK",
                newGame: "New Game", easyDifficulty: "Easy (6 guesses)", mediumDifficulty: "Medium (8 guesses)", hardDifficulty: "Hard (10 guesses)",
                languageLabel: "Language:", translateUI: "Translate UI", showOriginal: "Show Original",
                translationStatusLoading: "Loading translations...", translationStatusError: "Translation failed. Using English.",
                translationStatusNoAPI: "API needed for translation.", translationStatusSuccess: "{language} translations applied.",
                aiSettingsTitle: "AI Word Generation & Details (Optional)", apiKeyWarning: "Note: API key is stored only for this browser session.",
                apiKeyPlaceholder: "Enter AI API Key", useAILabel: "Use AI", testApiButton: "Test/Save Key",
                apiStatusInitial: "Enter key and click Test/Save.", apiStatusTesting: "Testing {model}...",
                apiStatusSuccess: "{model} connection successful! Key saved for this session.",
                apiStatusFailed: "Connection failed: {error}. Check key/model/network.", apiStatusChanged: "API key changed. Please Test/Save.",
                apiStatusUsingAI: "{model} active this session. Using AI for words/details.", apiStatusUsingDetailsOnly: "{model} active this session. Using AI for details only.",
                apiStatusNotVerified: "Key entered for {model}, but not verified. Click Test/Save."
            };
            let isTranslationEnabled = false;
            let currentLanguage = 'en';
            let translationsCache = { 'en': { ...ORIGINAL_STRINGS } };
            let isFetchingTranslation = false;
            // --- End Translation State ---

            // --- Session Storage Helpers ---
            function saveToSessionStorage(key, value) { try { sessionStorage.setItem(key, JSON.stringify(value)); } catch (e) { console.error("Error saving to sessionStorage:", e); } }
            function loadFromSessionStorage(key, defaultValue) { try { const item = sessionStorage.getItem(key); return item ? JSON.parse(item) : defaultValue; } catch (e) { console.error("Error loading from sessionStorage:", e); return defaultValue; } }

            // --- Initialization ---
            function init() { /* ... (same element getting and event listener setup) ... */ console.log("Hangman: init() starting."); gameContainerElement = document.getElementById('game-container'); detailsPopupOverlay = document.getElementById('details-popup-overlay'); detailsPopupContent = document.getElementById('details-popup-content'); detailsPopupTitle = document.getElementById('details-popup-title'); const okBtn = document.getElementById('details-popup-ok-btn'); if (!gameContainerElement || !detailsPopupOverlay || !detailsPopupContent || !detailsPopupTitle || !okBtn) { console.error("CRITICAL ERROR - Core UI elements not found!"); updateStatusMessage("Initialization Failed! UI Missing."); return; } okBtn.addEventListener('click', hideDetailsPopup); const difficultySelect = document.getElementById('difficulty-select'); if (difficultySelect) { currentDifficulty = difficultySelect.value; maxWrongGuesses = HANGMAN_PART_COUNT[currentDifficulty]; } else { console.warn("Difficulty select not found, defaulting to medium."); currentDifficulty = 'medium'; maxWrongGuesses = HANGMAN_PART_COUNT.medium; } isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 600; console.log(`Mobile = ${isMobile}, Difficulty = ${currentDifficulty}`); try { setupScene(); setupPhysics(); initUI(); renderGameState(); const header = document.getElementById('game-container-header'); if (!isMobile && header) { makeDraggable(gameContainerElement, header, document.body); } else if (isMobile && header) { header.style.cursor = 'default'; } console.log("Starting first game..."); startNewGame().then(() => { console.log("First game setup complete (async)."); if (!animationFrameId) { animate(); } }).catch(err => { console.error("Error during initial startNewGame:", err); updateStatusMessage("Error starting game. Check console."); renderGameState(); }); } catch (error) { console.error("CRITICAL ERROR during init() sequence:", error); updateStatusMessage("Initialization Failed! Check console."); wordSource = "(Error)"; gameOver = true; renderGameState(); if(gameContainerElement) { const errorDiv = document.createElement('div'); errorDiv.style.color = 'red'; errorDiv.style.marginTop = '10px'; errorDiv.style.fontWeight = 'bold'; errorDiv.textContent = `Initialization Error: ${error.message}. See console.`; gameContainerElement.appendChild(errorDiv); } } }
            function makeDraggable(elmnt, header, boundsElement) { /* ... (same) ... */ if (!elmnt || !header || !boundsElement) { console.warn("Draggable elements or bounds not found"); return; } let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; header.onmousedown = dragMouseDown; function dragMouseDown(e) { e = e || window.event; e.preventDefault(); pos3 = e.clientX; pos4 = e.clientY; document.onmouseup = closeDragElement; document.onmousemove = elementDrag; elmnt.style.opacity = "0.9"; } function elementDrag(e) { e = e || window.event; e.preventDefault(); pos1 = pos3 - e.clientX; pos2 = pos4 - e.clientY; pos3 = e.clientX; pos4 = e.clientY; let newTop = elmnt.offsetTop - pos2; let newLeft = elmnt.offsetLeft - pos1; const elmntWidth = elmnt.offsetWidth; const elmntHeight = elmnt.offsetHeight; const maxTop = boundsElement.clientHeight - elmntHeight; const maxLeft = boundsElement.clientWidth - elmntWidth; newTop = Math.max(0, Math.min(newTop, maxTop < 0 ? 0 : maxTop)); newLeft = Math.max(0, Math.min(newLeft, maxLeft < 0 ? 0 : maxLeft)); elmnt.style.top = newTop + "px"; elmnt.style.left = newLeft + "px"; } function closeDragElement() { document.onmouseup = null; document.onmousemove = null; elmnt.style.opacity = "1"; } }
            function initUI() { /* ... (same API setup and listeners) ... */ apiKey = sessionStorage.getItem('hangmanApiKey') || ''; const storedModel = localStorage.getItem('hangmanApiModel'); if (storedModel && ['gemini-1.5-flash', 'openai', 'anthropic'].includes(storedModel)) { apiModel = storedModel; } else { apiModel = 'gemini-1.5-flash'; localStorage.setItem('hangmanApiModel', apiModel); } useApiForWords = localStorage.getItem('hangmanUseApi') === 'true'; const apiKeyInput = document.getElementById('api-key-input'); const apiModelSelect = document.getElementById('api-model-select'); const useApiCheckbox = document.getElementById('use-api-checkbox'); const newGameBtn = document.getElementById('new-game-btn'); const difficultySelect = document.getElementById('difficulty-select'); const testApiBtn = document.getElementById('test-api-btn'); const languageSelect = document.getElementById('language-select'); const translateToggleBtn = document.getElementById('translate-toggle-btn'); if (apiKeyInput) apiKeyInput.value = apiKey; if (apiModelSelect) apiModelSelect.value = apiModel; if (useApiCheckbox) useApiCheckbox.checked = useApiForWords; if (difficultySelect) difficultySelect.value = currentDifficulty; updateApiStatusDisplay(); if (newGameBtn) newGameBtn.addEventListener('click', startNewGame); if (testApiBtn) testApiBtn.addEventListener('click', testAndSaveApiSettings); if (useApiCheckbox) useApiCheckbox.addEventListener('change', function() { useApiForWords = this.checked; localStorage.setItem('hangmanUseApi', useApiForWords); updateApiStatusDisplay(); if (useApiForWords && !isApiWorking && apiKey) { updateApiStatusDisplay("apiStatusChanged"); } }); if (apiKeyInput) apiKeyInput.addEventListener('input', () => { apiKey = apiKeyInput.value.trim(); isApiWorking = false; updateApiStatusDisplay("apiStatusChanged"); }); if (difficultySelect) difficultySelect.addEventListener('change', () => { currentDifficulty = difficultySelect.value; maxWrongGuesses = HANGMAN_PART_COUNT[currentDifficulty]; console.log('Difficulty changed to ' + currentDifficulty + ', Max Guesses: ' + maxWrongGuesses); }); if (apiModelSelect) apiModelSelect.addEventListener('change', function() { apiModel = this.value; localStorage.setItem('hangmanApiModel', apiModel); isApiWorking = false; updateApiStatusDisplay(); }); /* ... (same translation UI setup) ... */ isTranslationEnabled = loadFromSessionStorage('hangmanTranslationEnabled', false); currentLanguage = loadFromSessionStorage('hangmanCurrentLanguage', 'en'); translationsCache = loadFromSessionStorage('hangmanTranslationsCache', { 'en': { ...ORIGINAL_STRINGS } }); if (!SUPPORTED_LANGUAGES[currentLanguage]) { currentLanguage = 'en'; saveToSessionStorage('hangmanCurrentLanguage', currentLanguage); } if (!translationsCache['en']) { translationsCache['en'] = { ...ORIGINAL_STRINGS }; saveToSessionStorage('hangmanTranslationsCache', translationsCache); } if (languageSelect) { languageSelect.innerHTML = ''; Object.entries(SUPPORTED_LANGUAGES).forEach(([code, name]) => { const option = document.createElement('option'); option.value = code; option.textContent = name; if (code === currentLanguage) { option.selected = true; } languageSelect.appendChild(option); }); languageSelect.addEventListener('change', (event) => changeLanguage(event.target.value)); } if (translateToggleBtn) { translateToggleBtn.addEventListener('click', toggleTranslation); updateToggleButtonState(); } if (isTranslationEnabled && currentLanguage !== 'en') { applyTranslation(); } else { revertToOriginal(); } updateTranslationStatus(); setupKeyboardControls(); }

            // --- Scene & Physics Setup ---
            function setupScene() { /* ... (same) ... */ console.log("Hangman: setupScene() starting..."); try { scene = new THREE.Scene(); scene.background = new THREE.Color(0x87CEEB); const containerWidth = window.innerWidth; const containerHeight = window.innerHeight; console.log(`Window dimensions: ${containerWidth}x${containerHeight}`); if(containerWidth <= 0 || containerHeight <= 0) { console.warn("Window has zero dimensions on setup!"); } camera = new THREE.PerspectiveCamera(70, containerWidth / Math.max(containerHeight, 1), 0.1, 1000); camera.position.set(0, 1, 12); camera.lookAt(0, 1, 0); renderer = new THREE.WebGLRenderer({ antialias: !isMobile, powerPreference: "high-performance", alpha: false }); renderer.setSize(containerWidth, containerHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2)); renderer.shadowMap.enabled = !isMobile; if (!isMobile) { renderer.shadowMap.type = THREE.PCFSoftShadowMap; } document.body.appendChild(renderer.domElement); const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); scene.add(ambientLight); const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); directionalLight.position.set(8, 15, 10); directionalLight.castShadow = !isMobile; if (!isMobile) { directionalLight.shadow.mapSize.width = 1024; directionalLight.shadow.mapSize.height = 1024; directionalLight.shadow.camera.near = 1; directionalLight.shadow.camera.far = 50; directionalLight.shadow.camera.left = -15; directionalLight.shadow.camera.right = 15; directionalLight.shadow.camera.top = 15; directionalLight.shadow.camera.bottom = -15; } scene.add(directionalLight); const groundGeometry = new THREE.PlaneGeometry(100, 100); const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x90EE90, roughness: 0.9, metalness: 0.1 }); const ground = new THREE.Mesh(groundGeometry, groundMaterial); ground.rotation.x = -Math.PI / 2; ground.position.y = -4.5; ground.receiveShadow = !isMobile; scene.add(ground); controls = new THREE.OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.dampingFactor = 0.05; controls.minDistance = 4; controls.maxDistance = 30; controls.maxPolarAngle = Math.PI / 2 - 0.05; controls.target.set(0, 1, 0); controls.update(); window.addEventListener('resize', onCanvasContainerResize); console.log("Scene setup finished."); } catch (error) { console.error("Error during setupScene:", error); throw error; } }
            function setupPhysics() { /* ... (same) ... */ console.log("Hangman: setupPhysics() starting..."); try { world = new CANNON.World(); world.gravity.set(0, -9.82, 0); world.broadphase = new CANNON.NaiveBroadphase(); world.solver.iterations = 10; world.allowSleep = true; const groundShape = new CANNON.Plane(); groundBody = new CANNON.Body({ mass: 0, shape: groundShape }); groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2); groundBody.position.set(0, -4.5, 0); world.addBody(groundBody); console.log("Physics world created."); } catch (error) { console.error("Error during setupPhysics:", error); throw error; } }

            // --- Gallows & Hangman Creation ---
            function createGallows() { /* ... (same) ... */ console.log("Creating gallows..."); try { Object.values(gallows).forEach(mesh => { if (mesh && mesh.parent) mesh.parent.remove(mesh); }); gallows = { base: null, pole: null, beam: null, support: null, rope: null }; gallowsBodies.forEach(body => { if (body.world) world.remove(body); }); gallowsBodies = []; const baseGeo = new THREE.BoxGeometry(6, 0.8, 2); gallows.base = new THREE.Mesh(baseGeo, woodMaterial); gallows.base.position.y = -4.1; gallows.base.castShadow = !isMobile; gallows.base.receiveShadow = !isMobile; scene.add(gallows.base); const poleGeo = new THREE.BoxGeometry(0.8, 8, 0.8); gallows.pole = new THREE.Mesh(poleGeo, woodMaterial); gallows.pole.position.set(-2.5, 0, 0); gallows.pole.castShadow = !isMobile; gallows.pole.receiveShadow = !isMobile; scene.add(gallows.pole); const beamGeo = new THREE.BoxGeometry(4.5, 0.8, 0.8); gallows.beam = new THREE.Mesh(beamGeo, woodMaterial); gallows.beam.position.set(-0.25, 4.0, 0); gallows.beam.castShadow = !isMobile; gallows.beam.receiveShadow = !isMobile; scene.add(gallows.beam); const supportGeo = new THREE.BoxGeometry(3.5, 0.6, 0.6); gallows.support = new THREE.Mesh(supportGeo, woodMaterial); gallows.support.position.set(-1.5, 2.5, 0); gallows.support.rotation.z = Math.PI / 4; gallows.support.castShadow = !isMobile; gallows.support.receiveShadow = !isMobile; scene.add(gallows.support); const ropeGeo = new THREE.CylinderGeometry(0.08, 0.08, 1.8, 8); gallows.rope = new THREE.Mesh(ropeGeo, ropeMaterial); gallows.rope.position.set(1.7, 3.1, 0); gallows.rope.castShadow = !isMobile; scene.add(gallows.rope); const addStaticBody = (shape, position, quaternion) => { const body = new CANNON.Body({ mass: 0, shape }); body.position.copy(position); if (quaternion) body.quaternion.copy(quaternion); world.addBody(body); gallowsBodies.push(body); }; addStaticBody(new CANNON.Box(new CANNON.Vec3(3, 0.4, 1)), gallows.base.position); addStaticBody(new CANNON.Box(new CANNON.Vec3(0.4, 4, 0.4)), gallows.pole.position); addStaticBody(new CANNON.Box(new CANNON.Vec3(2.25, 0.4, 0.4)), gallows.beam.position); console.log("Gallows created."); } catch (error) { console.error("Error during createGallows:", error); } }
            function createHangmanParts() { /* ... (same) ... */ console.log("Creating hangman parts..."); try { hangmanParts.forEach(part => { if (part.mesh && part.mesh.parent) part.mesh.parent.remove(part.mesh); }); hangmanPhysicsBodies.forEach(item => { if (item.body && item.body.world) world.remove(item.body); }); hangmanParts = []; hangmanPhysicsBodies = []; smileFaceGroup = null; grumpyFaceGroup = null; headMainSphere = null; const partsToCreate = HANGMAN_PART_COUNT[currentDifficulty] || 0; if (partsToCreate <= 0) { console.warn("No hangman parts to create."); return; } const headBasePosition = new THREE.Vector3(1.7, 1.7, 0); smileFaceGroup = new THREE.Group(); smileFaceGroup.visible = false; const eyeRadius = 0.15; const eyeY = 0.1; const eyeZ = 0.48; const smileEyeGeo = new THREE.SphereGeometry(0.06, 12, 8); const smileLeftEye = new THREE.Mesh(smileEyeGeo, faceDetailMaterial); smileLeftEye.position.set(-eyeRadius, eyeY, eyeZ); smileFaceGroup.add(smileLeftEye); const smileRightEye = new THREE.Mesh(smileEyeGeo, faceDetailMaterial); smileRightEye.position.set(eyeRadius, eyeY, eyeZ); smileFaceGroup.add(smileRightEye); const smileGeo = new THREE.TorusGeometry(0.2, 0.03, 8, 16, Math.PI); const smileMouth = new THREE.Mesh(smileGeo, faceDetailMaterial); smileMouth.position.set(0, -0.15, eyeZ - 0.02); smileMouth.rotation.z = Math.PI; smileFaceGroup.add(smileMouth); grumpyFaceGroup = new THREE.Group(); grumpyFaceGroup.visible = false; const crossSize = 0.35; const crossThickness = 0.03; const eyeX = 0.20; const eyeYGrumpy = 0.1; const eyeZGrumpy = 0.45; const crossGeo = new THREE.CylinderGeometry(crossThickness, crossThickness, crossSize, 6); const l_eye1 = new THREE.Mesh(crossGeo, faceDetailMaterial); l_eye1.position.set(-eyeX, eyeYGrumpy, eyeZGrumpy); l_eye1.rotation.z = Math.PI / 4; grumpyFaceGroup.add(l_eye1); const l_eye2 = new THREE.Mesh(crossGeo, faceDetailMaterial); l_eye2.position.set(-eyeX, eyeYGrumpy, eyeZGrumpy); l_eye2.rotation.z = -Math.PI / 4; grumpyFaceGroup.add(l_eye2); const r_eye1 = new THREE.Mesh(crossGeo, faceDetailMaterial); r_eye1.position.set(eyeX, eyeYGrumpy, eyeZGrumpy); r_eye1.rotation.z = Math.PI / 4; grumpyFaceGroup.add(r_eye1); const r_eye2 = new THREE.Mesh(crossGeo, faceDetailMaterial); r_eye2.position.set(eyeX, eyeYGrumpy, eyeZGrumpy); r_eye2.rotation.z = -Math.PI / 4; grumpyFaceGroup.add(r_eye2); const grumpyMouthGeo = new THREE.BoxGeometry(0.4, 0.05, 0.05); const grumpyMouth = new THREE.Mesh(grumpyMouthGeo, faceDetailMaterial); grumpyMouth.position.set(0, -0.18, eyeZGrumpy + 0.03); grumpyFaceGroup.add(grumpyMouth); const partDefinitions = [ { name: "head", geo: new THREE.SphereGeometry(0.5, 24, 18), mat: skinMaterial, pos: [headBasePosition.x, headBasePosition.y, headBasePosition.z], physShape: new CANNON.Sphere(0.5), mass: 3 }, { name: "body", geo: new THREE.BoxGeometry(0.9, 1.4, 0.5), mat: blueMaterial, pos: [1.7, 0.5, 0], physShape: new CANNON.Box(new CANNON.Vec3(0.45, 0.7, 0.25)), mass: 6 }, { name: "l_arm", geo: new THREE.BoxGeometry(0.8, 0.3, 0.3), mat: blueMaterial, pos: [1.0, 0.9, 0], rot: [0, 0, 0.3], physShape: new CANNON.Box(new CANNON.Vec3(0.4, 0.15, 0.15)), mass: 1 }, { name: "r_arm", geo: new THREE.BoxGeometry(0.8, 0.3, 0.3), mat: blueMaterial, pos: [2.4, 0.9, 0], rot: [0, 0, -0.3], physShape: new CANNON.Box(new CANNON.Vec3(0.4, 0.15, 0.15)), mass: 1 }, { name: "l_leg", geo: new THREE.BoxGeometry(0.3, 0.9, 0.3), mat: blackMaterial, pos: [1.45, -0.4, 0], physShape: new CANNON.Box(new CANNON.Vec3(0.15, 0.45, 0.15)), mass: 2 }, { name: "r_leg", geo: new THREE.BoxGeometry(0.3, 0.9, 0.3), mat: blackMaterial, pos: [1.95, -0.4, 0], physShape: new CANNON.Box(new CANNON.Vec3(0.15, 0.45, 0.15)), mass: 2 }, { name: "l_foot", geo: new THREE.BoxGeometry(0.35, 0.2, 0.45), mat: blackMaterial, pos: [1.45, -0.9, 0.05], physShape: new CANNON.Box(new CANNON.Vec3(0.175, 0.1, 0.225)), mass: 0.5 }, { name: "r_foot", geo: new THREE.BoxGeometry(0.35, 0.2, 0.45), mat: blackMaterial, pos: [1.95, -0.9, 0.05], physShape: new CANNON.Box(new CANNON.Vec3(0.175, 0.1, 0.225)), mass: 0.5 }, { name: "hat", geo: new THREE.CylinderGeometry(0.3, 0.4, 0.3, 16), mat: blackMaterial, pos: [1.7, 2.25, 0], physShape: new CANNON.Cylinder(0.3, 0.4, 0.3, 8), mass: 0.5 } ]; for (let i = 0; i < partsToCreate; i++) { if (i >= partDefinitions.length) { console.log(`Ran out of part definitions at index ${i}`); hangmanParts.push({ mesh: null }); continue; } const def = partDefinitions[i]; if (!def) { console.warn(`Part definition missing for index ${i}`); hangmanParts.push({ mesh: null }); continue; } const mesh = new THREE.Mesh(def.geo, def.mat); mesh.position.set(...def.pos); if (def.rot) mesh.rotation.set(...def.rot); mesh.castShadow = !isMobile; mesh.visible = false; mesh.name = def.name; scene.add(mesh); if (def.name === "head") { headMainSphere = mesh; mesh.add(smileFaceGroup); mesh.add(grumpyFaceGroup); console.log("Added faces to head mesh."); } const body = new CANNON.Body({ mass: def.mass, shape: def.physShape, position: new CANNON.Vec3(...def.pos), linearDamping: 0.2, angularDamping: 0.2 }); if(def.rot) { const euler = new THREE.Euler(...def.rot, 'XYZ'); body.quaternion.setFromEuler(euler.x, euler.y, euler.z, 'XYZ'); } body.name = def.name; body.allowSleep = true; body.sleep(); hangmanPhysicsBodies.push({ mesh: mesh, body: body }); hangmanParts.push({ mesh: mesh }); } console.log(`Finished creating ${hangmanParts.length} part entries.`); } catch (error) { console.error("Error during createHangmanParts:", error); } }

            // --- UI Updates ---
            function renderGameState() { /* ... (same logic, calls applyStaticTranslations, updateStatusMessage etc.) ... */ applyStaticTranslations(); try { updateStatusMessage(statusMessage); const sourceEl = document.getElementById('word-source'); if (sourceEl) { sourceEl.textContent = wordSource ? `(${getTranslation('sourcePrefix')} ${wordSource})` : ''; } const wordDisplayEl = document.getElementById('word-display'); if (wordDisplayEl) { if (currentWord && currentWord !== "ERROR") { const display = currentWord.split('').map(letter => (guessedLetters.includes(letter) || gameOver) ? letter : '_').join(''); wordDisplayEl.textContent = display.split('').join(' '); } else if (currentWord === "ERROR") { wordDisplayEl.textContent = "E R R O R"; } else { wordDisplayEl.textContent = ""; } } const usedLettersEl = document.getElementById('used-letters'); if (usedLettersEl) { usedLettersEl.textContent = guessedLetters.sort().join(', '); } createLetterButtons(); updateApiStatusDisplay(); updateTranslationStatus(); updateToggleButtonState(); } catch (uiError) { console.error("Error updating UI:", uiError); updateStatusMessage("UI Update Error!"); } }
            function updateStatusMessage(newMessageOrKey, params = {}) { /* ... (same) ... */ let messageText = newMessageOrKey; const statusEl = document.getElementById('status'); if (!statusEl) return; if (ORIGINAL_STRINGS[newMessageOrKey]) { messageText = getTranslation(newMessageOrKey, null, params); statusMessage = messageText; statusEl.textContent = messageText; } else { statusMessage = newMessageOrKey; statusEl.textContent = newMessageOrKey; } }
            function createLetterButtons() { /* ... (same) ... */ const container = document.getElementById('letters-container'); if (!container) return; container.innerHTML = ''; if (!currentWord || currentWord === "ERROR" || statusMessage === getTranslation('statusLoading') || statusMessage === getTranslation('statusStartingGame') || statusMessage === getTranslation('statusChoosingWord') || statusMessage.includes('Getting')) { return; } for (let i = 65; i <= 90; i++) { const letter = String.fromCharCode(i); const button = document.createElement('button'); button.textContent = letter; button.className = 'letter-button'; button.dataset.letter = letter; const isGuessed = guessedLetters.includes(letter); button.disabled = gameOver || isGuessed; button.classList.toggle('disabled', button.disabled); if (isGuessed) { const correct = currentWord.includes(letter); button.classList.toggle('correct', correct); button.classList.toggle('incorrect', !correct); } button.addEventListener('click', () => handleGuess(letter)); container.appendChild(button); } }

            // --- Game Logic ---
            async function startNewGame() { /* ... (same, calls hideDetailsPopup) ... */ console.log(`--- Start New Game --- Difficulty: ${currentDifficulty}`); gameOver = false; wrongGuesses = 0; guessedLetters = []; currentWord = ""; wordSource = ""; hideDetailsPopup(); updateStatusMessage('statusStartingGame'); renderGameState(); try { console.log("Resetting physics bodies..."); hangmanPhysicsBodies.forEach(item => { if (item?.body?.world) world.remove(item.body); }); gallowsBodies.forEach(body => { if (body?.world) world.remove(body); }); hangmanPhysicsBodies = []; gallowsBodies = []; console.log("Physics bodies removed."); createGallows(); createHangmanParts(); console.log("Visual elements recreated."); } catch (resetError) { console.error("Error resetting scene/physics:", resetError); updateStatusMessage("Error resetting game visuals! Check console."); wordSource = "(Error)"; currentWord = "ERROR"; gameOver = true; renderGameState(); if (!animationFrameId) animate(); return; } try { let word = null; let apiAttempted = false; updateStatusMessage('statusChoosingWord'); renderGameState(); if (useApiForWords && isApiWorking) { apiAttempted = true; const friendlyModelName = getFriendlyApiModelName(apiModel); updateStatusMessage(`Getting ${currentDifficulty} word from ${friendlyModelName}...`); renderGameState(); word = await getWordFromApi(); if (word) { console.log("API Success:", word); wordSource = 'AI'; } else { console.warn("API failed/invalid/duplicate. Falling back."); updateStatusMessage(`AI failed. Using local ${currentDifficulty} word...`); wordSource = 'Local'; renderGameState(); } } if (!word) { if (!apiAttempted) { console.log(`Using local ${currentDifficulty} word list.`); wordSource = 'Local'; updateStatusMessage(`Using local ${currentDifficulty} word...`); renderGameState(); } else { console.log(`Fell back to local ${currentDifficulty} word list.`); } const words = DEFAULT_WORDS[currentDifficulty]; if (!words || words.length === 0) throw new Error(`No local words for ${currentDifficulty}`); word = words[Math.floor(Math.random() * words.length)]; console.log("Selected local word:", word); if (!wordSource) wordSource = 'Local'; } currentWord = word.toUpperCase(); updateStatusMessage('statusGuess', { guessesLeft: maxWrongGuesses - wrongGuesses }); console.log(`Final Word: "${currentWord}", Source: ${wordSource}`); } catch (error) { console.error("CRITICAL error getting word:", error); updateStatusMessage(`Error: ${error.message}. Try New Game.`); wordSource = '(Error)'; currentWord = "ERROR"; gameOver = true; } finally { renderGameState(); console.log("--- End New Game ---"); } }
            function handleGuess(letter) { /* ... (same) ... */ if (gameOver || guessedLetters.includes(letter) || !currentWord || currentWord === "ERROR") return; guessedLetters.push(letter); if (currentWord.includes(letter)) { updateStatusMessage('statusCorrect', { letter: letter }); checkWinCondition(); } else { wrongGuesses++; updateStatusMessage('statusWrong', { letter: letter, guessesLeft: maxWrongGuesses - wrongGuesses }); revealHangmanPart(); checkLossCondition(); } renderGameState(); }
            function revealHangmanPart() { /* ... (same) ... */ if (wrongGuesses <= 0 || wrongGuesses > hangmanParts.length) { console.warn(`Invalid wrongGuesses (${wrongGuesses}) or index out of bounds (${hangmanParts.length})`); return; } const partIndex = wrongGuesses - 1; console.log(`Revealing part index ${partIndex} (Wrong Guesses: ${wrongGuesses})`); const part = hangmanParts[partIndex]; if (part && part.mesh) { const partMesh = part.mesh; if (!partMesh.visible) { console.log(`Making mesh "${partMesh.name}" visible.`); partMesh.visible = true; if (partIndex === 0 && headMainSphere) { if(smileFaceGroup) smileFaceGroup.visible = true; if(grumpyFaceGroup) grumpyFaceGroup.visible = false; console.log("Revealed head, showing smile face."); } const originalScale = partMesh.scale.clone(); partMesh.scale.set(1.3, 1.3, 1.3); let startTime = performance.now(); function scaleDown() { if (!partMesh || !partMesh.parent) return; const elapsed = performance.now() - startTime; const progress = Math.min(elapsed / 150, 1); const scale = 1.3 - 0.3 * progress; partMesh.scale.set(scale, scale, scale); if (progress < 1) { requestAnimationFrame(scaleDown); } else { partMesh.scale.copy(originalScale); } } requestAnimationFrame(scaleDown); } else { console.log(`Part mesh "${partMesh.name}" at index ${partIndex} was already visible.`); } } else { console.warn(`Attempted to reveal part index ${partIndex}, but part or mesh was missing/null.`); } if (currentDifficulty === 'hard' && wrongGuesses === maxWrongGuesses - FACE_CHANGE_GUESS_OFFSET) { if (smileFaceGroup && grumpyFaceGroup && headMainSphere && headMainSphere.visible) { smileFaceGroup.visible = false; grumpyFaceGroup.visible = true; console.log("Switched to grumpy face for hard mode nearing end."); } } }
            function checkWinCondition() { /* ... (same, calls triggerFetchAndDisplayWordDetails) ... */ if (!currentWord || gameOver) return; if (currentWord.split('').every(char => guessedLetters.includes(char))) { updateStatusMessage('statusWin', { word: currentWord }); gameOver = true; renderGameState(); console.log("--- Game Won ---"); triggerFetchAndDisplayWordDetails(currentWord); } }
            function checkLossCondition() { /* ... (same, calls triggerFetchAndDisplayWordDetails) ... */ if (gameOver) return; if (wrongGuesses >= maxWrongGuesses) { updateStatusMessage('statusLoss', { word: currentWord }); gameOver = true; renderGameState(); console.log("--- Game Lost --- Activating Physics"); activateHangmanPhysics(); triggerFetchAndDisplayWordDetails(currentWord); } }
            function activateHangmanPhysics() { /* ... (same) ... */ console.log("--- Activating Physics ---"); if (!world) { console.error("Cannot activate physics, world not initialized."); return; } if (gallows.rope && gallows.rope.parent) { scene.remove(gallows.rope); gallows.rope = null; console.log("Removed visual rope."); } const tempWorldPos = new THREE.Vector3(); const tempWorldQuat = new THREE.Quaternion(); let physicsActivatedCount = 0; hangmanPhysicsBodies.forEach((item, index) => { if (!item?.body || !item?.mesh) { console.warn(`Skipping physics activation for item ${index}, body or mesh missing.`); return; } const meshName = item.mesh.name || `mesh_${index}`; if(!item.mesh.visible) { console.warn(`Physics body mesh ${meshName} is not visible! Making it visible.`); item.mesh.visible = true; } if (item.mesh === headMainSphere) { if (smileFaceGroup) smileFaceGroup.visible = (currentDifficulty !== 'hard'); if (grumpyFaceGroup) grumpyFaceGroup.visible = (currentDifficulty === 'hard'); } if (!item.body.world) { try { world.addBody(item.body); physicsActivatedCount++; } catch (addError) { console.error(`ERROR adding body ${meshName} to world:`, addError); return; } } item.body.sleepState = CANNON.Body.AWAKE; item.body.velocity.set(0,0,0); item.body.angularVelocity.set(0,0,0); item.body.force.set(0,0,0); item.body.torque.set(0,0,0); try { item.mesh.getWorldPosition(tempWorldPos); item.body.position.copy(tempWorldPos); item.mesh.getWorldQuaternion(tempWorldQuat); item.body.quaternion.copy(tempWorldQuat); const impulseStrength = 1.5 + Math.random() * 1.0; const randomVec = new CANNON.Vec3( (Math.random() - 0.5) * impulseStrength, (Math.random() - 0.8) * impulseStrength, (Math.random() - 0.5) * impulseStrength ); const point = new CANNON.Vec3( (Math.random() - 0.5) * 0.2, (Math.random() - 0.5) * 0.2, (Math.random() - 0.5) * 0.2 ); item.body.applyImpulse(randomVec, point); item.body.angularVelocity.set( (Math.random() - 0.5) * 6, (Math.random() - 0.5) * 6, (Math.random() - 0.5) * 6 ); } catch (syncError) { console.error(`Error syncing/applying impulse to body ${meshName}:`, syncError); } }); if (physicsActivatedCount === 0 && hangmanPhysicsBodies.length > 0) { console.warn("No new physics bodies were added during activation."); } else if (hangmanPhysicsBodies.length === 0) { console.warn("No hangman physics bodies found to activate."); } console.log(`--- Finished Activating Physics (${physicsActivatedCount} bodies added/woken) ---`); }

             // --- Details Popup & Fetching ---
             function triggerFetchAndDisplayWordDetails(word) { /* ... (same logic, calls showDetailsPopup and fetchBilingualWordDetails) ... */ if (!isApiWorking || !apiKey) { showDetailsPopup(word, { error: getTranslation('detailsApiNeeded') }); return; } if (!word || word === "ERROR") { showDetailsPopup(word, { error: getTranslation('detailsInvalidWord') }); return; } showDetailsPopup(word, { loading: true }); console.log(`Fetching details for "${word}" (Lang: ${currentLanguage}) using ${apiModel}`); fetchBilingualWordDetails(word, currentLanguage).then(details => { if (details && !details.error) { showDetailsPopup(word, details); } else { const errorMsg = details?.error || getTranslation('detailsFetchFailed', null, { word: word }); showDetailsPopup(word, { error: errorMsg }); console.warn(`Failed to get details object for "${word}". Error: ${errorMsg}`); } }).catch(error => { console.error(`Error fetching word details for "${word}":`, error); showDetailsPopup(word, { error: getTranslation('detailsFetchError', null, { word: word }) }); }); }

            // MODIFIED: Show Details Popup - uses getTranslation for labels and displays transcription
            function showDetailsPopup(word, details) {
                 if (!detailsPopupOverlay || !detailsPopupContent || !detailsPopupTitle) return;

                 // Use getTranslation for the title
                 detailsPopupTitle.textContent = getTranslation('detailsTitle', 'Details for "{word}"', { word: word });
                 // Translate OK button text
                 const okBtn = document.getElementById('details-popup-ok-btn');
                 if (okBtn) okBtn.textContent = getTranslation('okButton', 'OK');

                 let contentHtml = '';

                 if (details.loading) {
                     contentHtml = `<p>${getTranslation('detailsFetching', 'Fetching details...')}</p>`;
                 } else if (details.error) {
                     contentHtml = `<p class="error">${details.error}</p>`; // Show fetch error
                 } else {
                     const targetLangName = SUPPORTED_LANGUAGES[currentLanguage] || currentLanguage;
                     const isTargetEnglish = currentLanguage === 'en';
                     const hasTranslationData = !isTargetEnglish && details.translation;

                     // --- Word Translation and Transcription ---
                     if (hasTranslationData) {
                         contentHtml += `<div class="word-translation-block">`;
                         // Translation
                         if (details.translation.wordTranslation) {
                             contentHtml += `<span class="word-translation"><strong>${getTranslation('wordTranslationLabel', 'Translation ({language})', { language: targetLangName })}:</strong> ${details.translation.wordTranslation}</span>`;
                         } else {
                             contentHtml += `<span class="word-translation error"><strong>${getTranslation('wordTranslationLabel', 'Translation ({language})', { language: targetLangName })}:</strong> ${getTranslation('translationError', 'Translation not available')}</span>`;
                         }
                         // Transcription
                         if (details.translation.wordTranscription) {
                            contentHtml += `<span class="word-transcription">(${getTranslation('wordTranscriptionLabel', 'Transcription')}: ${details.translation.wordTranscription})</span>`;
                         }
                         contentHtml += `</div>`;
                     }

                     // --- English Content ---
                     contentHtml += `<h5>${getTranslation('englishContentLabel', 'English')}</h5>`;
                     if (details.english?.definition) {
                         contentHtml += `<p><strong>${getTranslation('definitionLabel', 'Definition')}:</strong> ${details.english.definition}</p>`;
                     } else {
                         contentHtml += `<p><strong>${getTranslation('definitionLabel', 'Definition')}:</strong> <span class="error">${getTranslation('notAvailable', 'N/A')}</span></p>`;
                     }
                     if (details.english?.examples && details.english.examples.length > 0) {
                          contentHtml += `<p><strong>${getTranslation('examplesLabel', 'Examples')}:</strong></p>`;
                          details.english.examples.forEach((ex, i) => {
                              if (ex) contentHtml += `<p style="margin-left: 15px;">${i + 1}. ${ex}</p>`;
                          });
                     } else {
                          contentHtml += `<p><strong>${getTranslation('examplesLabel', 'Examples')}:</strong> <span class="error">${getTranslation('notAvailable', 'N/A')}</span></p>`;
                     }

                     // --- Translated Content ---
                     if (hasTranslationData) {
                         contentHtml += `<div class="section-separator"></div>`;
                         // Use getTranslation for the header, substituting the language name
                         contentHtml += `<h5>${getTranslation('translatedContentLabel', '{language}', { language: targetLangName })}</h5>`;

                         if (details.translation?.definition) {
                             contentHtml += `<p><strong>${getTranslation('definitionLabel', 'Definition')}:</strong> ${details.translation.definition}</p>`;
                         } else {
                             contentHtml += `<p><strong>${getTranslation('definitionLabel', 'Definition')}:</strong> <span class="error">${getTranslation('translationError', 'Translation not available')}</span></p>`;
                         }
                         if (details.translation?.examples && details.translation.examples.length > 0) {
                             contentHtml += `<p><strong>${getTranslation('examplesLabel', 'Examples')}:</strong></p>`;
                             details.translation.examples.forEach((ex, i) => {
                                 if (ex) contentHtml += `<p style="margin-left: 15px;">${i + 1}. ${ex}</p>`;
                             });
                              if (details.translation.examples.length === 1 && details.english?.examples?.length === 2) {
                                  contentHtml += `<p><em>(${getTranslation('detailsOneExampleOnly', 'Only one example sentence found.')})</em></p>`;
                              }
                         } else {
                             contentHtml += `<p><strong>${getTranslation('examplesLabel', 'Examples')}:</strong> <span class="error">${getTranslation('translationError', 'Translation not available')}</span></p>`;
                         }
                     }
                 }

                 detailsPopupContent.innerHTML = contentHtml;
                 detailsPopupOverlay.style.display = 'flex'; // Show the popup
            }
            function hideDetailsPopup() { /* ... (same) ... */ if (detailsPopupOverlay) { detailsPopupOverlay.style.display = 'none'; } }

            // --- API Integration ---
            function getFriendlyApiModelName(modelId) { /* ... (same) ... */ switch(modelId) { case 'gemini-1.5-flash': return 'Google Gemini Flash'; case 'openai': return 'OpenAI GPT-3.5'; case 'anthropic': return 'Anthropic Claude Haiku'; default: return modelId; } }
            async function testAndSaveApiSettings() { /* ... (same) ... */ apiKey = document.getElementById('api-key-input')?.value.trim() || ''; apiModel = document.getElementById('api-model-select')?.value || 'gemini-1.5-flash'; const friendlyModelName = getFriendlyApiModelName(apiModel); if (!apiKey) { updateApiStatusDisplay("Please enter an API key.", 'orange'); isApiWorking = false; sessionStorage.removeItem('hangmanApiKey'); if (isTranslationEnabled && currentLanguage !== 'en') updateTranslationStatus(); return; } updateApiStatusDisplay('apiStatusTesting', { model: friendlyModelName }, 'blue'); isApiWorking = false; try { const testPrompt = "Respond with only the single word 'test'."; const result = await fetchFromApi(testPrompt); if (result && result.toLowerCase().includes('test')) { updateApiStatusDisplay('apiStatusSuccess', { model: friendlyModelName }, 'green'); isApiWorking = true; sessionStorage.setItem('hangmanApiKey', apiKey); localStorage.setItem('hangmanApiModel', apiModel); if (isTranslationEnabled && currentLanguage !== 'en' && !translationsCache[currentLanguage]) { applyTranslation(); } else { updateTranslationStatus(); } } else { throw new Error(`API test failed. Unexpected response: ${result || '(empty response)'}`); } } catch (error) { console.error('API test error:', error); const errorMsg = error.message || 'Unknown error'; updateApiStatusDisplay('apiStatusFailed', { error: errorMsg }, 'red'); isApiWorking = false; sessionStorage.removeItem('hangmanApiKey'); if (isTranslationEnabled && currentLanguage !== 'en') updateTranslationStatus(); } }
            function updateApiStatusDisplay(messageKeyOrText = null, params = {}, color = '#555') { /* ... (same) ... */ const statusEl = document.getElementById('api-status'); if (!statusEl) return; const friendlyModelName = getFriendlyApiModelName(apiModel); let statusText = ''; const sessionApiKey = sessionStorage.getItem('hangmanApiKey'); if (!sessionApiKey || sessionApiKey !== apiKey) { if (isApiWorking && apiKey) { console.log("API Status Check: Key mismatch or empty, marking API as not working."); } isApiWorking = false; } if (messageKeyOrText && ORIGINAL_STRINGS[messageKeyOrText]) { let baseText = getTranslation(messageKeyOrText); if (['apiStatusTesting', 'apiStatusSuccess', 'apiStatusUsingAI', 'apiStatusUsingDetailsOnly', 'apiStatusNotVerified'].includes(messageKeyOrText)) { params.model = friendlyModelName; } Object.keys(params).forEach(key => { const regex = new RegExp(`\\{${key}\\}`, 'g'); baseText = baseText.replace(regex, params[key]); }); statusText = baseText; statusEl.style.color = color; statusEl.textContent = statusText; } else if (messageKeyOrText) { statusText = messageKeyOrText; statusEl.style.color = color; statusEl.textContent = statusText; } else { const keyEntered = !!apiKey; if (!keyEntered) { updateApiStatusDisplay('apiStatusInitial', {}, '#555'); isApiWorking = false; } else if (isApiWorking) { const statusKey = useApiForWords ? 'apiStatusUsingAI' : 'apiStatusUsingDetailsOnly'; updateApiStatusDisplay(statusKey, { model: friendlyModelName }, 'green'); } else { updateApiStatusDisplay('apiStatusNotVerified', { model: friendlyModelName }, 'orange'); } } }
            async function fetchFromApi(prompt, maxTokens = 100) { /* ... (same) ... */ if (!apiKey) throw new Error("API key is missing"); let apiEndpoint = '', requestData = {}, headers = { 'Content-Type': 'application/json' }; const friendlyModelName = getFriendlyApiModelName(apiModel); console.log(`[fetchFromApi] Sending request to ${friendlyModelName} (Max Tokens: ${maxTokens})`); try { const needsJson = prompt.includes("Respond ONLY with a valid JSON object"); if (apiModel === 'gemini-1.5-flash') { apiEndpoint = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`; requestData = { contents: [{ parts: [{ text: prompt }] }], generationConfig: { maxOutputTokens: maxTokens, temperature: 0.5, topP: 0.9, responseMimeType: needsJson ? "application/json" : "text/plain" } }; } else if (apiModel === 'openai') { apiEndpoint = 'https://api.openai.com/v1/chat/completions'; headers['Authorization'] = `Bearer ${apiKey}`; requestData = { model: 'gpt-3.5-turbo', messages: [{ role: 'user', content: prompt }], max_tokens: maxTokens, temperature: 0.5 }; if (needsJson) { requestData.response_format = { type: "json_object" }; } } else if (apiModel === 'anthropic') { apiEndpoint = 'https://api.anthropic.com/v1/messages'; headers['anthropic-version'] = '2023-06-01'; headers['x-api-key'] = apiKey; requestData = { model: 'claude-3-haiku-20240307', max_tokens: maxTokens, messages: [{ role: 'user', content: prompt }], temperature: 0.5 }; } else { throw new Error(`Unsupported API model: ${apiModel}`); } const response = await fetch(apiEndpoint, { method: 'POST', headers: headers, body: JSON.stringify(requestData), signal: AbortSignal.timeout(35000) }); if (!response.ok) { let errorBody = `Status: ${response.status}`; try { const errorJson = await response.json(); errorBody = JSON.stringify(errorJson.error || errorJson); } catch (e) { try { errorBody = await response.text(); } catch (e2) {} } throw new Error(`API request failed. ${errorBody.substring(0, 200)}`); } const data = await response.json(); let responseText = ''; if (apiModel === 'gemini-1.5-flash') { responseText = data.candidates?.[0]?.content?.parts?.[0]?.text || ''; } else if (apiModel === 'openai') { responseText = data.choices?.[0]?.message?.content || ''; } else if (apiModel === 'anthropic') { responseText = data.content?.find(block => block.type === 'text')?.text || ''; } return responseText.trim(); } catch (error) { console.error(`[fetchFromApi] API error for ${friendlyModelName}:`, error); if (error.name === 'TimeoutError') { throw new Error("API request timed out."); } if (error.message && (error.message.includes('401') || error.message.toLowerCase().includes('invalid api key') || error.message.toLowerCase().includes('authentication error'))) { isApiWorking = false; sessionStorage.removeItem('hangmanApiKey'); updateApiStatusDisplay('apiStatusFailed', { error: 'Authentication failed. Check key.' }, 'red'); if (isTranslationEnabled && currentLanguage !== 'en') updateTranslationStatus(); } throw error; } }
            async function getWordFromApi() { /* ... (same) ... */ const wordType = currentDifficulty === "easy" ? "simple common" : currentDifficulty === "medium" ? "moderately common" : "less common but recognizable"; const lengthRange = currentDifficulty === "easy" ? "4-7" : currentDifficulty === "medium" ? "6-10" : "10-16"; const uniqueifier = Date.now(); const randomSeed = Math.floor(Math.random() * 10000); const excludeList = previousApiWords.length > 0 ? `\nDO NOT use any of these words (case-insensitive): ${previousApiWords.join(', ')}.` : ''; const prompt = `Generate a **random**, single English word suitable for a hangman game. Request ID: ${uniqueifier}-${randomSeed}\n\nWord characteristics:\n- Difficulty: ${currentDifficulty} (${wordType})\n- Length: Approximately ${lengthRange} letters\n- Must be a real dictionary word\n- Must contain ONLY standard English letters (A-Z)\n- Must be safe for all ages${excludeList}\n\nIMPORTANT: Respond with ONLY the single word itself, nothing else (no explanations, quotes, punctuation, or introduction).`; console.log(`[getWordFromApi] Difficulty: ${currentDifficulty}, Random seed: ${randomSeed}, Attempting to exclude: ${previousApiWords.join(', ')}`); let attempts = 0; const maxAttempts = 3; while (attempts < maxAttempts) { attempts++; try { const response = await fetchFromApi(prompt, 25); if (!response) { console.warn(`[getWordFromApi] API returned empty response on attempt ${attempts}`); if (attempts < maxAttempts) await new Promise(resolve => setTimeout(resolve, 300)); continue; } let potentialWord = response.match(/^[a-zA-Z]+$/)?.[0] || response.split(/[\s\n,.:;"']/)[0].replace(/[^a-zA-Z]/g, ''); const cleanedWord = potentialWord.toUpperCase(); const minLen = currentDifficulty === "easy" ? 3 : currentDifficulty === "medium" ? 5 : 8; const maxLen = currentDifficulty === "easy" ? 9 : currentDifficulty === "medium" ? 14 : 20; const isValid = cleanedWord.length >= minLen && cleanedWord.length <= maxLen && /^[A-Z]+$/.test(cleanedWord); if (isValid && !previousApiWords.includes(cleanedWord)) { previousApiWords.push(cleanedWord); if (previousApiWords.length > MAX_STORED_WORDS) { previousApiWords.shift(); } console.log(`[getWordFromApi] Valid, non-duplicate word found: "${cleanedWord}" (attempt ${attempts})`); return cleanedWord; } else { if (!isValid) console.warn(`[getWordFromApi] Word "${cleanedWord}" (from raw: "${response}") failed validation (len: ${cleanedWord.length}, allowed: ${minLen}-${maxLen}) - trying again (attempt ${attempts}/${maxAttempts})`); if (previousApiWords.includes(cleanedWord)) console.warn(`[getWordFromApi] Duplicate word "${cleanedWord}" received - trying again (attempt ${attempts}/${maxAttempts})`); if (attempts < maxAttempts) await new Promise(resolve => setTimeout(resolve, 300)); } } catch (error) { console.error(`[getWordFromApi] Error during attempt ${attempts}:`, error.message); if (attempts >= maxAttempts) { console.error("[getWordFromApi] API fetch error occurred on final attempt."); break; } await new Promise(resolve => setTimeout(resolve, 500)); } } console.error("[getWordFromApi] Failed to get a valid, unique word after", maxAttempts, "attempts. Falling back."); return null; }

             // MODIFIED: Fetch BILINGUAL Details including Transcription
             async function fetchBilingualWordDetails(word, targetLangCode) {
                 if (!isApiWorking || !apiKey || !word) return null;
                 const targetLangName = SUPPORTED_LANGUAGES[targetLangCode] || targetLangCode;
                 let prompt;

                 // MODIFIED: Added wordTranscription to desired structure
                 const desiredJsonStructure = `{
  "english": {
    "definition": "Concise English definition of the word.",
    "examples": [
      "First distinct English example sentence using the word.",
      "Second distinct English example sentence, ideally showing a different usage if applicable."
    ]
  },
  "translation": {
    "targetLanguage": "${targetLangName}",
    "wordTranslation": "The translation of the word '${word}' into ${targetLangName}.",
    "wordTranscription": "A simple phonetic transcription of the English word '${word}' using ${targetLangName} script/phonetics (e.g., using Cyrillic for Bulgarian like 'трейн' for 'train', or IPA if simpler). If transcription is complex or ambiguous, provide the most common one, or null if not feasible.",
    "definition": "Concise ${targetLangName} translation of the English definition.",
    "examples": [
      "${targetLangName} translation of the first English example sentence.",
      "${targetLangName} translation of the second English example sentence."
    ]
  }
}`;
                 if (targetLangCode === 'en') { /* ... (same prompt for English only) ... */ prompt = `Provide details for the English word "${word}". Respond ONLY with a valid JSON object with the following structure:\n{\n  "english": {\n    "definition": "Concise English definition.",\n    "examples": ["English example 1.", "English example 2."]\n  }\n}`; }
                 else { prompt = `Provide details for the English word "${word}" and its translation into ${targetLangName} (${targetLangCode}). Respond ONLY with a valid JSON object following this exact structure, filling in the requested information:\n${desiredJsonStructure}\n\nIMPORTANT: Ensure the response is solely the JSON object, without any introduction, explanation, or markdown formatting. Provide concise definitions and two distinct examples in both languages. For wordTranscription, use ${targetLangName} script/phonetics or simple IPA.`; }

                 try {
                     const rawResponse = await fetchFromApi(prompt, 2500); // Increased token allowance
                     console.log("Raw bilingual details response:", rawResponse);
                     let parsedDetails = null;
                     try { const cleanedResponse = rawResponse.replace(/^```json\s*|\s*```$/g, ''); parsedDetails = JSON.parse(cleanedResponse); }
                     catch (parseError) { console.error("Failed to parse details JSON:", parseError, "Raw:", rawResponse); if (rawResponse.length < 200 && !rawResponse.includes('{')) { return { english: { definition: rawResponse, examples: [] }, translation: null }; } throw new Error("API response was not valid JSON."); }

                     if (parsedDetails && parsedDetails.english && parsedDetails.english.definition) {
                         if (targetLangCode !== 'en' && !parsedDetails.translation) { console.warn(`Translation object missing in response for ${targetLangCode}.`); parsedDetails.translation = null; }
                         // Ensure transcription is null if empty string
                         if (parsedDetails.translation && parsedDetails.translation.wordTranscription === "") {
                            parsedDetails.translation.wordTranscription = null;
                         }
                         return parsedDetails;
                     } else { console.error("Parsed JSON is missing required 'english' structure:", parsedDetails); throw new Error("Received JSON is missing expected structure."); }
                 } catch (error) { console.error("Error fetching bilingual word details:", error); return { error: error.message || "Failed to fetch details." }; }
             }


            // --- UI Translation Functions ---
            function getTranslation(key, fallback = null, params = {}) { /* ... (same) ... */ const lang = isTranslationEnabled ? currentLanguage : 'en'; let text = translationsCache[lang]?.[key] ?? translationsCache['en']?.[key] ?? fallback ?? key; Object.keys(params).forEach(paramKey => { const regex = new RegExp(`\\{${paramKey}\\}`, 'g'); text = text.replace(regex, params[paramKey]); }); return text; }
            function updateToggleButtonState() { /* ... (same) ... */ const translateToggleBtn = document.getElementById('translate-toggle-btn'); if (translateToggleBtn) { translateToggleBtn.textContent = isTranslationEnabled ? getTranslation('showOriginal') : getTranslation('translateUI'); } }
            function updateTranslationStatus(messageKey = null, params = {}, color = '#666') { /* ... (same) ... */ const statusEl = document.getElementById('translation-status'); if (!statusEl) return; if (messageKey) { statusEl.textContent = getTranslation(messageKey, messageKey, params); statusEl.style.color = color; } else { if (isTranslationEnabled && currentLanguage !== 'en') { if (isFetchingTranslation) { updateTranslationStatus('translationStatusLoading', {}, 'blue'); } else if (translationsCache[currentLanguage]) { updateTranslationStatus('translationStatusSuccess', { language: SUPPORTED_LANGUAGES[currentLanguage] }, 'green'); } else if (!isApiWorking || !apiKey) { updateTranslationStatus('translationStatusNoAPI', {}, 'orange'); } else { updateTranslationStatus('translationStatusError', {}, 'red'); } } else { statusEl.textContent = ''; } } }
            function toggleTranslation() { /* ... (same) ... */ isTranslationEnabled = !isTranslationEnabled; console.log("Translation toggled:", isTranslationEnabled); saveToSessionStorage('hangmanTranslationEnabled', isTranslationEnabled); updateToggleButtonState(); if (isTranslationEnabled) { applyTranslation(); } else { revertToOriginal(); } updateTranslationStatus(); renderGameState(); } // Added renderGameState call
            function changeLanguage(langCode) { /* ... (same) ... */ if (!SUPPORTED_LANGUAGES[langCode] || langCode === currentLanguage) { return; } currentLanguage = langCode; console.log("Language changed to:", currentLanguage); saveToSessionStorage('hangmanCurrentLanguage', currentLanguage); if (isTranslationEnabled) { applyTranslation(); } else { updateToggleButtonState(); updateTranslationStatus(); renderGameState(); } } // Added renderGameState call
            function applyTranslation() { /* ... (same) ... */ console.log(`Applying translation for: ${currentLanguage}`); if (!isTranslationEnabled || currentLanguage === 'en') { revertToOriginal(); updateTranslationStatus(); return; } if (translationsCache[currentLanguage]) { console.log("Using cached translations for", currentLanguage); updateUIWithTranslations(currentLanguage); updateTranslationStatus(); } else if (isApiWorking && apiKey) { console.log("Fetching translations for", currentLanguage); fetchAndCacheTranslations(currentLanguage); } else { console.warn("Cannot fetch translation: API not working/key missing."); revertToOriginal(); updateTranslationStatus('translationStatusNoAPI', {}, 'orange'); } renderGameState(); } // Added renderGameState call
             async function fetchAndCacheTranslations(langCode) { /* ... (same) ... */ if (isFetchingTranslation) { console.log("Translation fetch already in progress for", langCode); return; } if (!isApiWorking || !apiKey) { console.error("Cannot fetch: API not ready."); revertToOriginal(); updateTranslationStatus('translationStatusNoAPI', {}, 'orange'); return; } isFetchingTranslation = true; updateTranslationStatus('translationStatusLoading', {}, 'blue'); const languageName = SUPPORTED_LANGUAGES[langCode] || langCode; const stringsToTranslate = JSON.stringify(ORIGINAL_STRINGS, null, 2); const prompt = `Translate the following English UI text elements into ${languageName} (${langCode}). Respond ONLY with a valid JSON object where keys match the provided English keys and values are the ${languageName} translations. Do not include explanations or markdown formatting. Ensure the JSON is complete and valid.\n\n${stringsToTranslate}`; try { const rawResponse = await fetchFromApi(prompt, 2500); console.log("Raw translation response:", rawResponse); let parsedTranslations = null; try { const cleanedResponse = rawResponse.replace(/^```json\s*|\s*```$/g, ''); parsedTranslations = JSON.parse(cleanedResponse); } catch (parseError) { console.error("Failed to parse translation JSON:", parseError, "Raw:", rawResponse); throw new Error("API response was not valid JSON."); } if (parsedTranslations && typeof parsedTranslations === 'object') { if (parsedTranslations.gameTitle && parsedTranslations.newGame) { translationsCache[langCode] = parsedTranslations; saveToSessionStorage('hangmanTranslationsCache', translationsCache); console.log(`Translations for ${langCode} fetched and cached.`); updateUIWithTranslations(langCode); updateTranslationStatus(); } else { console.error("Parsed JSON seems incomplete or invalid:", parsedTranslations); throw new Error("Received JSON is missing expected keys."); } } else { throw new Error("Parsed response is not a valid object."); } } catch (error) { console.error(`Error fetching translations for ${langCode}:`, error); revertToOriginal(); updateTranslationStatus('translationStatusError', {}, 'red'); } finally { isFetchingTranslation = false; renderGameState(); } } // Added renderGameState call
             function applyStaticTranslations() { /* ... (same) ... */ const lang = isTranslationEnabled ? currentLanguage : 'en'; if (translationsCache[lang]) { updateUIWithTranslations(lang); } else { updateUIWithTranslations('en'); } }
             function updateUIWithTranslations(langCode) { /* ... (same logic, includes popup OK button now) ... */ console.log("Updating UI with translations for:", langCode); const translations = translationsCache[langCode]; if (!translations) { console.error("No translations available for", langCode); revertToOriginal(); return; } document.querySelectorAll('[data-translate-key]').forEach(element => { const key = element.getAttribute('data-translate-key'); const translatedText = translations[key]; if (translatedText !== undefined) { if (element.tagName === 'INPUT' && element.placeholder !== undefined) { element.placeholder = translatedText; } else if (element.tagName === 'OPTION') { element.textContent = translatedText; } else if (element.tagName === 'TITLE') { document.title = translatedText; } else { element.textContent = translatedText; } } else if (langCode !== 'en') { const fallbackText = translationsCache['en']?.[key]; if (fallbackText !== undefined) { if (element.tagName === 'INPUT' && element.placeholder !== undefined) element.placeholder = fallbackText; else if (element.tagName === 'OPTION') element.textContent = fallbackText; else if (element.tagName === 'TITLE') document.title = fallbackText; else element.textContent = fallbackText; console.warn(`Missing translation for key '${key}' in ${langCode}. Used English fallback.`); } else { console.warn(`Missing translation and English fallback for key '${key}'.`); } } }); updateStatusMessage(statusMessage); updateToggleButtonState(); /* updateApiStatusDisplay(); // Done by renderGameState */ }
            function revertToOriginal() { /* ... (same) ... */ console.log("Reverting UI to original English"); updateUIWithTranslations('en'); updateTranslationStatus(); }

            // --- Event Handlers & Loop ---
            function onCanvasContainerResize() { /* ... (same) ... */ if (!camera || !renderer) return; const newWidth = window.innerWidth; const newHeight = window.innerHeight; if (newWidth > 0 && newHeight > 0) { camera.aspect = newWidth / newHeight; camera.updateProjectionMatrix(); renderer.setSize(newWidth, newHeight); console.log(`Hangman Iframe: Resized to ${newWidth}x${newHeight}`); } else { console.warn("Hangman Iframe: Window resize triggered with zero dimensions."); } }
            function setupKeyboardControls() { /* ... (same) ... */ document.addEventListener('keydown', (event) => { const activeElement = document.activeElement; const isInGameUI = gameContainerElement && gameContainerElement.contains(activeElement); const isInputFocused = activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.tagName === 'SELECT'); if (gameOver || event.ctrlKey || event.metaKey || event.altKey || !currentWord || currentWord==="ERROR") return; if (isInGameUI && isInputFocused) { return; } if (event.key.length === 1 && event.key.match(/[a-z]/i)) { const letter = event.key.toUpperCase(); const button = document.querySelector(`#letters-container .letter-button[data-letter="${letter}"]`); if (button && !button.disabled) { handleGuess(letter); } } }); }
            function animate() { /* ... (same) ... */ animationFrameId = requestAnimationFrame(animate); const deltaTime = 1 / 60; let frameRendered = false; try { if (gameOver && world && hangmanPhysicsBodies.length > 0 && hangmanPhysicsBodies[0]?.body?.world) { world.step(deltaTime); hangmanPhysicsBodies.forEach(item => { if (item?.body && item?.mesh) { item.mesh.position.copy(item.body.position); item.mesh.quaternion.copy(item.body.quaternion); } }); } } catch (physicsError) { console.error("Hangman Iframe: Physics step/sync error:", physicsError); } try { if (controls) controls.update(); if (renderer && scene && camera) { renderer.render(scene, camera); frameRendered = true; } else { if (!renderer) console.warn("Hangman Iframe: Animate - Renderer missing!"); if (!scene) console.warn("Hangman Iframe: Animate - Scene missing!"); if (!camera) console.warn("Hangman Iframe: Animate - Camera missing!"); } } catch (renderError) { console.error("Hangman Iframe: Render error in animate loop:", renderError); } }

            // --- Start Initializing ---
            init();

        } // End of initHangmanGame
    </script>
</body>
</html>
